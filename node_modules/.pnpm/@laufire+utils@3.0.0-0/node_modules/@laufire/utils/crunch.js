"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.group = exports.transpose = exports.descend = exports.summarize = exports.index = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _collection = require("./collection");

var _predicates = require("./predicates");

/* Helpers */

/* Exports */
var index = function index(collection, indexes) {
  var indexKeys = (0, _collection.values)(indexes).reverse();
  return _collection.combine.apply(void 0, (0, _toConsumableArray2["default"])((0, _collection.values)((0, _collection.map)(collection, function (item) {
    return indexKeys.reduce(function (agg, indexKey, i) {
      return (0, _defineProperty2["default"])({}, item[indexKey], i === 0 ? [agg] : agg);
    }, item);
  }))));
};

exports.index = index;

var descend = function descend(collection, process, level) {
  return level ? (0, _collection.map)(collection, function (item) {
    return descend(item, process, level - 1);
  }) : (0, _collection.map)(collection, process);
};

exports.descend = descend;

var summarize = function summarize(collection, indexes, summarizer, initial) {
  return descend(index(collection, indexes), function (indexed) {
    return (0, _collection.reduce)(indexed, summarizer, initial);
  }, indexes.length - 1);
};

exports.summarize = summarize;

var transpose = function transpose(collection) {
  return (0, _collection.gather)(collection, (0, _collection.filter)((0, _collection.values)((0, _collection.map)(collection, _collection.keys)).flat(), _predicates.unique));
};

exports.transpose = transpose;

var group = function group(collection, grouper) {
  return (0, _collection.reduce)(collection, function (acc, item) {
    for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      rest[_key - 2] = arguments[_key];
    }

    var category = grouper.apply(void 0, [item].concat(rest));
    acc[category] = [].concat((0, _toConsumableArray2["default"])(acc[category] || []), [item]);
    return acc;
  }, {});
};

exports.group = group;