"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _collection = require("@laufire/utils/collection");

var _helpers = require("../test/helpers");

var _reflection = require("./reflection");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

describe('Reflection', function () {
  /* Mocks and Stubs */
  // TODO: Move all possible values to test helpers.
  var fn = function fn() {};

  var Constructor = fn;
  var constructed = new Constructor();
  /* Tests */

  test('constructorName returns the constructor name' + ' of the given value', function () {
    var expectations = {
      Object: _helpers.object,
      Array: _helpers.array,
      Function: fn,
      String: '',
      Number: 1,
      Date: new Date(),
      fn: constructed
    };
    (0, _collection.map)(expectations, function (value, expectation) {
      return expect((0, _reflection.constructorName)(value)).toEqual(expectation);
    });
    [null, undefined].forEach(function (value) {
      return expect((0, _reflection.constructorName)(value)).toEqual(undefined);
    });
  });
  test('inferType infers the type of the given value', function () {
    var expectations = (0, _helpers.allTypes)();
    (0, _collection.map)(expectations, function (value, type) {
      return expect((0, _reflection.inferType)(value)).toEqual(type);
    });
  });
  test('isCollection is an alias for isIterable', function () {
    expect(_reflection.isCollection).toEqual(_reflection.isIterable);
  });
  test('isIterable returns true only when the given value' + ' is an Array or an Object', function () {
    expect((0, _reflection.isIterable)(_helpers.object)).toEqual(true);
    expect((0, _reflection.isIterable)(_helpers.array)).toEqual(true);
    expect((0, _reflection.isIterable)(fn)).toEqual(false);
  });
  test('isFunction returns true only when the given value' + ' is a Function', function () {
    expect((0, _reflection.isFunction)(_helpers.object)).toEqual(false);
    expect((0, _reflection.isFunction)(fn)).toEqual(true);
  });
  test('isDict returns true only when the given value' + ' is an Object', function () {
    expect((0, _reflection.isDict)(_helpers.object)).toEqual(true);
    expect((0, _reflection.isDict)(_helpers.array)).toEqual(false);
  });
  test('isObject returns true only when the given value' + ' is an Objectish', function () {
    expect((0, _reflection.isObject)(_helpers.object)).toEqual(true);
    expect((0, _reflection.isObject)(constructed)).toEqual(true);
    expect((0, _reflection.isObject)(_helpers.array)).toEqual(false);
  });
  test('isDefined returns false only when the given value' + ' is undefined', function () {
    (0, _collection.map)((0, _helpers.allTypes)(), function (value) {
      (0, _helpers.expectEquals)((0, _reflection.isDefined)(value), value !== undefined);
    });
  });
  test('isEmpty', function () {
    var emptyValues = (0, _collection.values)((0, _helpers.emptyTypes)());
    (0, _collection.map)((0, _helpers.allTypes)(), function (value) {
      return expect((0, _reflection.isEmpty)(value)).toEqual(emptyValues.includes(value));
    });
  });
  test('isSimple', function () {
    var simpleValues = (0, _helpers.simpleTypes)();

    var collection = _objectSpread(_objectSpread({}, (0, _helpers.allTypes)()), simpleValues);

    (0, _collection.map)(collection, function (value) {
      return expect((0, _reflection.isSimple)(value)).toEqual((0, _collection.values)(simpleValues).includes(value));
    });
    expect((0, _reflection.isSimple)(NaN)).toEqual(false);
  });
});