"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _debug = require("./debug");

/* eslint-disable no-console */
// TODO: Try to use package config instead.
beforeEach(function () {
  jest.clearAllMocks();
});
var value = Symbol('value');
describe('peek - a drop in console.log replacement with better devEx', function () {
  console.log = jest.fn();
  test('peek logs a value to the console and returns the same value.', function () {
    var ret = (0, _debug.peek)(value);
    expect(ret).toBe(value);
    expect(console.log).toHaveBeenCalledWith(value);
  });
  test('peek supports an optional label.', function () {
    var label = Symbol('someLabel');
    (0, _debug.peek)(value, label);
    expect(console.log).toHaveBeenCalledWith(label, value);
  });
});
describe('pretty - returns the pretty JSON of the given value', function () {
  JSON.stringify = jest.fn();
  test('pretty calls the stringify with the given value and indent', function () {
    var indent = Symbol('indent');
    (0, _debug.pretty)(value, indent);
    expect(JSON.stringify).toHaveBeenCalledWith(value, null, indent);
  });
  test('indent defaults to tab', function () {
    (0, _debug.pretty)(value);
    expect(JSON.stringify).toHaveBeenCalledWith(value, null, '\t');
  });
});
test('sleep', function () {
  var resolve = Symbol('resolve');
  var ms = Symbol('ms');
  var defaultMS = 1000;
  var mockPromise = jest.fn().mockImplementation(function (cb) {
    return cb(resolve);
  });
  var mockSetTimeout = jest.fn().mockImplementation(function (arg, sec) {
    return {
      arg: arg,
      sec: sec
    };
  });
  jest.spyOn(global, 'Promise').mockImplementation(mockPromise);
  jest.spyOn(global, 'setTimeout').mockImplementation(mockSetTimeout);
  var expectations = [[ms, ms], [undefined, defaultMS]];
  expectations.map(function (_ref) {
    var _ref2 = (0, _slicedToArray2["default"])(_ref, 2),
        time = _ref2[0],
        expectation = _ref2[1];

    (0, _debug.sleep)(time);
    expect(mockSetTimeout).toHaveBeenCalledWith(resolve, expectation);
  });
});