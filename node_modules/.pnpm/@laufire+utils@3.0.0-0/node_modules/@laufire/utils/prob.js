"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.possibilities = exports.isProbable = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _toArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toArray"));

var _collection = require("@laufire/utils/collection");

var _lib = require("@laufire/utils/lib");

var _reflection = require("@laufire/utils/reflection");

var _random = require("./random");

var isProbable = function isProbable(probability) {
  return (// eslint-disable-next-line no-magic-numbers
    (0, _random.rndBetween)(1, 101) <= probability * 100
  );
}; // eslint-disable-next-line max-lines-per-function


exports.isProbable = isProbable;

var possibilities = function () {
  var arrayWorker = function arrayWorker(source) {
    var _clone$reverse = (0, _collection.clone)(source).reverse(),
        _clone$reverse2 = (0, _toArray2["default"])(_clone$reverse),
        first = _clone$reverse2[0],
        rest = _clone$reverse2.slice(1);

    return rest.reduce(function (acc, currentArray) {
      return currentArray.reduce(function (accOne, currentItem) {
        return (// eslint-disable-next-line max-nested-callbacks
          [].concat((0, _toConsumableArray2["default"])(accOne), (0, _toConsumableArray2["default"])(acc.map(function (prevItems) {
            return [currentItem].concat((0, _toConsumableArray2["default"])(prevItems));
          })))
        );
      }, []);
    }, first.map(function (x) {
      return [x];
    }));
  };

  var objectWorker = function objectWorker(source) {
    var transformed = (0, _collection.map)((0, _lib.entries)(source), function (value) {
      var _value = (0, _slicedToArray2["default"])(value, 2),
          name = _value[0],
          combos = _value[1];

      return arrayWorker([[name], combos]);
    });
    return (0, _collection.map)(arrayWorker(transformed), _collection.fromEntries);
  };

  var workers = {
    object: objectWorker,
    array: arrayWorker
  };
  return function (data) {
    return workers[(0, _reflection.inferType)(data)](data);
  };
}();

exports.possibilities = possibilities;