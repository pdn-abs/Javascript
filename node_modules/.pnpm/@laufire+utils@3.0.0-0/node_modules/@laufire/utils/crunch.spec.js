"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toArray"));

var _collection = require("@laufire/utils/collection");

var _random = require("@laufire/utils/random");

var _helpers = require("../test/helpers");

var _crunch = require("./crunch");

var _reflection = require("@laufire/utils/reflection");

/* Helpers */

/* Tested */

/* Spec */
describe('Crunch', function () {
  /* Helpers */
  var getMatcher = function getMatcher(acc) {
    return function (item) {
      var itemIndex = (0, _collection.findKey)(acc, function (val, key) {
        return val !== 'undefined' ? val !== item[key] : item.hasOwnProperty(key);
      });
      return !(0, _reflection.isDefined)(itemIndex);
    };
  };

  var testIndex = function testIndex(currentLevel, currentIndex, currentKeys, verify, data) {
    var _currentKeys = (0, _toArray2["default"])(currentKeys),
        currentKey = _currentKeys[0],
        rest = _currentKeys.slice(1);

    (0, _reflection.isDefined)(currentKey) ? (0, _collection.map)(currentLevel, function (child, key) {
      return testIndex(child, (0, _collection.merge)((0, _collection.shell)(currentIndex), currentIndex, (0, _defineProperty2["default"])({}, currentKey, key)), rest, verify, data);
    }) : verify(currentLevel, currentIndex, data);
  };

  describe('index builds an index for the given collection' + ' on the given keys of the children to help with retrieval', function () {
    test('example', function () {
      var taskOne = {
        task: 'bug',
        priority: 'important'
      };
      var taskTwo = {
        task: 'feature',
        priority: 'normal'
      };
      var taskThree = {
        task: 'refactoring',
        priority: 'normal'
      };
      var tasks = (0, _collection.secure)([taskTwo, taskThree, taskOne]);
      var taskIndex = (0, _crunch.index)(tasks, ['task']);
      var priorityIndex = (0, _crunch.index)(tasks, ['priority']);
      var multiIndex = (0, _crunch.index)(tasks, ['task', 'priority']);
      /* eslint-disable dot-notation */

      expect(taskIndex['bug']).toEqual([taskOne]);
      expect(priorityIndex['normal']).toEqual([taskTwo, taskThree]);
      expect(multiIndex['feature']['normal']).toEqual([taskTwo]);
      expect(multiIndex['feature']['important']).toEqual(undefined);
      /* eslint-enable dot-notation */
    });
    test('randomized test', function () {
      var verifyIndexed = function verifyIndexed(result, acc, data) {
        var expected = (0, _collection.values)(data).filter(getMatcher(acc));
        expect(result).toEqual(expected);
      };

      (0, _helpers.retry)(function () {
        var data = (0, _helpers.similarCols)();
        var indexKeys = (0, _helpers.rndKeys)((0, _random.rndValue)(data));
        var indexed = (0, _crunch.index)(data, indexKeys);
        testIndex(indexed, (0, _collection.shell)(data[0]), indexKeys, verifyIndexed, data);
      });
    });
  });
  describe('summarize summarizes the given collection' + ' and builds an index on the given keys', function () {
    test('example', function () {
      var summarizer = function summarizer(acc, _ref) {
        var cost = _ref.cost;
        return acc + cost;
      };

      var indexKeys = ['category', 'item'];
      var data = (0, _collection.secure)([{
        item: 'apple',
        category: 'fruit',
        cost: 2
      }, {
        item: 'burger',
        category: 'snack',
        cost: 1
      }, {
        item: 'burger',
        category: 'snack',
        cost: 2
      }]);
      var expected = {
        fruit: {
          apple: 2
        },
        snack: {
          burger: 3
        }
      };
      var result = (0, _crunch.summarize)(data, indexKeys, summarizer, 0);
      expect(result).toEqual(expected);
    });
    test('randomized test', function () {
      var summarizer = function summarizer(acc, item) {
        return acc.concat(item);
      };

      var initial = [];

      var verifySummarized = function verifySummarized(result, acc, data) {
        var filtered = (0, _collection.values)(data).filter(getMatcher(acc));
        var expected = filtered.reduce(summarizer, initial);
        expect(result).toEqual(expected);
      };

      (0, _helpers.retry)(function () {
        var data = (0, _helpers.similarCols)();
        var indexKeys = (0, _helpers.rndKeys)((0, _random.rndValue)(data));
        var summarized = (0, _crunch.summarize)(data, indexKeys, summarizer, initial);
        testIndex(summarized, {}, indexKeys, verifySummarized, data);
      });
    });
  });
  describe('descend descends into the given collection' + ' upto the given level and executes the given process' + ' and returns a new collection', function () {
    test('example', function () {
      var elmOne = {
        price: 10,
        tax: 2
      };
      var elmTwo = {
        price: 20,
        tax: 3
      };
      var data = (0, _collection.secure)([elmOne, elmTwo]);

      var increase = function increase(val) {
        return val + 1;
      };

      var expected = [{
        price: 11,
        tax: 3
      }, {
        price: 21,
        tax: 4
      }];
      var result = (0, _crunch.descend)(data, increase, 1);
      expect(result).toEqual(expected);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var marker = Symbol('marker');
        var depth = (0, _random.rndBetween)(1, 3);
        var level = (0, _random.rndBetween)(1, depth);

        var process = function process(value) {
          return [value, marker];
        };

        var source = (0, _helpers.rndNested)(depth + 1, 1, ['nested']);
        var result = (0, _crunch.descend)(source, process, level);

        var testDescend = function testDescend(output, input, currentLevel) {
          (0, _collection.map)(output, function (value, key) {
            currentLevel ? testDescend(value, input[key], currentLevel - 1) : expect(value).toEqual([input[key], marker]);
          });
        };

        testDescend(result, source, level);
      });
    });
  });
  describe('transpose swaps the first two levels' + ' of the given collection', function () {
    describe('examples', function () {
      test('transpose can transpose objects', function () {
        var input = {
          India: {
            population: 1380,
            status: 'developing'
          },
          UnitedStates: {
            population: 330,
            status: 'developed'
          },
          UnitedKingdom: {
            population: 70,
            status: 'developed',
            regent: 'Elizabeth'
          }
        };
        var transposed = {
          population: {
            India: 1380,
            UnitedStates: 330,
            UnitedKingdom: 70
          },
          status: {
            India: 'developing',
            UnitedStates: 'developed',
            UnitedKingdom: 'developed'
          },
          regent: {
            UnitedKingdom: 'Elizabeth'
          }
        };
        expect((0, _crunch.transpose)(input)).toEqual(transposed);
        expect((0, _crunch.transpose)(transposed)).toEqual(input);
      });
      test('transpose can transpose arrays', function () {
        var input = [['a', 1], ['b', 2], ['c', 3]];
        var transposed = [['a', 'b', 'c'], [1, 2, 3]];
        expect((0, _crunch.transpose)(input)).toEqual(transposed);
        expect((0, _crunch.transpose)(transposed)).toEqual(input);
      });
    });
    describe('randomized test', function () {
      test('transpose can transpose objects & arrays', function () {
        var input = (0, _helpers.rndNested)(3, 3, ['nested']);

        var testTransposed = function testTransposed(base, result) {
          var levelOneKeys = (0, _collection.keys)(base);
          var levelTwoKeys = (0, _collection.reduce)(base, function (acc, child) {
            return [].concat((0, _toConsumableArray2["default"])(acc), (0, _toConsumableArray2["default"])((0, _collection.keys)(child).filter(function (childKey) {
              return !acc.includes(childKey);
            })));
          }, []);
          (0, _collection.map)(levelOneKeys, function (levelOneKey) {
            return (0, _collection.map)(levelTwoKeys, function (levelTwoKey) {
              return expect(base[levelOneKey][levelTwoKey]).toEqual(result[levelTwoKey][levelOneKey]);
            });
          });
        };

        var transposed = (0, _crunch.transpose)(input);
        testTransposed(input, transposed);
        testTransposed(transposed, input);
      });
    });
  });
  describe('groups the given collection according to given grouper', function () {
    test('example', function () {
      var taskOne = {
        task: 'bugFix',
        priority: 1
      };
      var taskTwo = {
        task: 'feature',
        priority: 2
      };
      var data = [taskOne, taskTwo];

      var grouper = function grouper(_ref2) {
        var priority = _ref2.priority;
        return priority === 1 ? 'urgent' : 'trivial';
      };

      var expected = {
        urgent: [taskOne],
        trivial: [taskTwo]
      };
      var result = (0, _crunch.group)(data, grouper);
      expect(result).toEqual(expected);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var data = (0, _helpers.rndCollection)();
        var a = Symbol('groupA');
        var b = Symbol('groupB');
        var indexKeys = [a, b];
        var expected = [];
        var mockGrouper = jest.fn().mockImplementation(function (item) {
          var key = (0, _random.rndValue)(indexKeys);
          expected.push([key, item]);
          return key;
        });
        var grouped = (0, _crunch.group)(data, mockGrouper); // TODO: Use map instead of reduce post publishing.

        (0, _collection.reduce)(data, function (acc, item, key, collection) {
          expect(mockGrouper).toHaveBeenCalledWith(item, (0, _helpers.convertKey)(collection, key), collection);
        }, {});
        (0, _collection.map)(expected, function (_ref3) {
          var _ref4 = (0, _slicedToArray2["default"])(_ref3, 2),
              key = _ref4[0],
              item = _ref4[1];

          expect(grouped[key].includes(item)).toEqual(true);
        });
      });
    });
  });
});