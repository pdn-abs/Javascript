"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flatMap = exports.count = exports.length = exports.sort = exports.shuffle = exports.shares = exports.hasSame = exports.range = exports.lFindKey = exports.findLastKey = exports.findIndex = exports.findKey = exports.lFind = exports.findLast = exports.find = exports.adopt = exports.toDict = exports.toArray = exports.pick = exports.gather = exports.contains = exports.equals = exports.secure = exports.diff = exports.patch = exports.fill = exports.compose = exports.overlay = exports.merge = exports.combine = exports.squash = exports.clone = exports.assign = exports.shell = exports.translate = exports.flipMany = exports.flip = exports.result = exports.select = exports.omit = exports.sanitize = exports.clean = exports.hasKey = exports.has = exports.walk = exports.traverse = exports.nReduce = exports.reduce = exports.filter = exports.map = exports.each = exports.fromEntries = exports.entries = exports.values = exports.keys = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _reflection = require("./reflection");

var _lib = require("./lib");

var _sorters = require("./sorters");

var _path = require("./path");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/* NOTE: Exporting named imports (like keys) turns them into getters
 (probably by the compiler), this leads to some inconsistencies when
 mocking with jest. Hence, they are imported from the source.
*/
var abs = Math.abs,
    ceil = Math.ceil,
    sign = Math.sign;

var wrapAsArray = function wrapAsArray(value) {
  return (0, _reflection.isArray)(value) ? value : [value];
}; // eslint-disable-next-line id-length


var freeze = Object.freeze,
    preventExtensions = Object.preventExtensions,
    seal = Object.seal;
/* Exports */

var assign = _lib.assign;
exports.assign = assign;
var entries = _lib.entries;
exports.entries = entries;
var values = _lib.values;
exports.values = values;
var keys = _lib.keys;
/**
 * Returns an empty container of the same type as the given collection.
 * @param {*} collection The collection to get a shell for.
 */

exports.keys = keys;

var shell = function shell(collection) {
  return (0, _reflection.isArray)(collection) ? [] : {};
};

exports.shell = shell;

var fromEntries = function fromEntries(kvPairs) {
  return (0, _lib.values)(kvPairs).reduce(function (agg, pair) {
    agg[pair[0]] = pair[1];
    return agg;
  }, {});
}; // An Array.map like function for Iterables.


exports.fromEntries = fromEntries;

var map = function map(collection, cb) {
  var ret = shell(collection);
  var collectionKeys = (0, _lib.keys)(collection);
  collectionKeys.forEach(function (key) {
    return ret[key] = cb(collection[key], key, collection);
  });
  return ret;
};
/*
NOTE: The standard each implementation is avoided, as it doesn't align -
	with the principle of having a return value.
*/


exports.map = map;
var each = map; // An Array.filter like function for Objects.

exports.each = each;

var filter = function filter(iterable, cb) {
  return (0, _reflection.isArray)(iterable) ? iterable.filter(cb) // eslint-disable-next-line no-return-assign
  : (0, _lib.keys)(iterable).reduce(function (t, key) {
    return cb(iterable[key], key, iterable) && (t[key] = iterable[key]), t;
  }, {});
}; // An Array.reduce like function for Objects.


exports.filter = filter;

var reduce = function reduce(obj, reducer, initial) {
  var acc = initial;
  (0, _lib.keys)(obj).forEach(function (key) {
    acc = reducer(acc, obj[key], key, obj);
  });
  return acc;
};

exports.reduce = reduce;

var nReduce = function nReduce(obj, reducer, initial) {
  return reduce(obj, function (acc, value, key, collection) {
    return (0, _reflection.isIterable)(value) ? nReduce(value, reducer, acc) : reducer(acc, value, key, collection);
  }, initial);
};

exports.nReduce = nReduce;

var findKey = function findKey(collection, predicate) {
  var colKeys = (0, _lib.keys)(collection);
  return colKeys[colKeys.findIndex(function (key) {
    return predicate(collection[key], key, collection);
  })];
};

exports.findKey = findKey;
var findIndex = findKey;
exports.findIndex = findIndex;

var findLastKey = function findLastKey(collection, predicate) {
  var collectionKeys = (0, _lib.keys)(collection);
  var i = collectionKeys.length;
  var currentKey = Symbol('currentKey');

  while (!((currentKey = collectionKeys[--i]) === undefined || predicate(collection[currentKey], currentKey, collection))) {
    ;
  }

  return currentKey;
};

exports.findLastKey = findLastKey;
var lFindKey = findLastKey;
exports.lFindKey = lFindKey;

var find = function find(collection, predicate) {
  return collection[(0, _lib.keys)(collection).find(function (key) {
    return predicate(collection[key], key, collection);
  })];
};

exports.find = find;

var findLast = function findLast(collection, predicate) {
  var key = findLastKey(collection, predicate);
  return collection[(0, _reflection.isDefined)(key) ? key : Symbol('')];
};

exports.findLast = findLast;
var lFind = findLast;
/*
* Recursively passes all the primitives in the given collection
* to the given callback.
*/

exports.lFind = lFind;

var traverse = function () {
  var worker = function worker(cb, child, parentKey, parent) {
    return (0, _reflection.isIterable)(child) ? map(child, function (value, key) {
      return worker(cb, value, key, child);
    }) : cb(child, parentKey, parent);
  };

  return function (obj, cb) {
    return (0, _reflection.isIterable)(obj) ? map(obj, function (value, key) {
      return worker(cb, value, key, obj);
    }) : cb(obj);
  };
}();
/*
* Recursively passes all the props of the given collections
* to the given callback.
*/


exports.traverse = traverse;

var walk = function () {
  var walkWorker = function walkWorker(walker, child, parentKey, parent) {
    return (0, _reflection.isIterable)(child) ? walker(map(child, function (value, key) {
      return walkWorker(walker, value, key, child);
    }), child, parentKey, parent) : walker(undefined, child, parentKey, parent);
  };

  return function (obj, walker) {
    return walker((0, _reflection.isIterable)(obj) ? map(obj, function (value, key) {
      return walkWorker(walker, value, key, obj);
    }) : undefined, obj);
  };
}();

exports.walk = walk;

var clone = function () {
  var cloneObj = function cloneObj(obj) {
    return map(obj, clone);
  };

  var cloneArray = function cloneArray(arr) {
    return arr.map(clone);
  };

  return function (value) {
    return (0, _reflection.isDict)(value) ? cloneObj(value) : (0, _reflection.isArray)(value) ? cloneArray(value) : value;
  };
}();
/**
 * Has tells whether the given collection has the given value.
 * @param {*} collection The collection to collect the values from.
 * @param {*} value The props to collect from the children of the collection.
 */


exports.clone = clone;

var has = function has(collection, value) {
  return values(collection).indexOf(value) > -1;
};

exports.has = has;

var hasKey = function hasKey(collection, key) {
  return (0, _reflection.isIterable)(collection) && collection.hasOwnProperty(key);
}; // NOTE: Clean does not clean recursively to allow for shallow cleaning.


exports.hasKey = hasKey;

var clean = function clean(collection) {
  if ((0, _reflection.isArray)(collection)) return collection.filter(function (value) {
    return value !== undefined;
  });
  var ret = {};
  var objectKeys = (0, _lib.keys)(collection);
  var l = objectKeys.length;
  var i = 0;

  while (i < l) {
    var key = objectKeys[i++];
    var val = collection[key];
    if (val !== undefined) ret[key] = val;
  }

  return ret;
};
/* A recursive clean */


exports.clean = clean;

var sanitize = function sanitize(collection) {
  return clean(map(collection, function (value) {
    return (0, _reflection.isIterable)(value) ? sanitize(value) : value;
  }));
};

exports.sanitize = sanitize;

var select = function select(collection, selector) {
  var propsToSelect = values(selector);
  return filter(collection, function (dummy, key) {
    return propsToSelect.includes(key);
  });
};

exports.select = select;

var omit = function omit(obj, selector) {
  var propsToOmit = values(selector);
  return filter(obj, function (dummy, key) {
    return !propsToOmit.includes(key);
  });
};
/**
 * Gathers the given props from the children of the given collection,
 * as a collection.
 * @param {*} collection The collection to collect the values from.
 * @param {...any} props The props to collect from the children
 * of the collection.
 */
// eslint-disable-next-line no-shadow


exports.omit = omit;

var gather = function gather(collection, props) {
  var propShell = shell(collection);
  var ret = shell(values(collection)[0]);
  values(props).forEach(function (prop) {
    var child = shell(propShell);
    map(collection, function (value, key) {
      return value.hasOwnProperty(prop) && (child[key] = value[prop]);
    });
    ret[prop] = child;
  });
  return ret;
};
/**
 * Picks the given prop from the children of the given collection,
 * as a collection.
 * @param {*} collection The collection to collect the values from.
 * @param {any} props The props to collect from the children of the collection.
 */
// TODO: Rewrite for performance.


exports.gather = gather;

var pick = function pick(collection, prop) {
  return gather(collection, [prop])[prop];
};
/**
 * Combines multiple objects and their descendants with the given base object.
 * When immutability is required, a shell could be passed as the base object.
 * @param {collection} base The base collection on which
 * the extensions would be combined to.
 * @param {...collection} extensions The extensions to be combined.
 */


exports.pick = pick;

var combine = function () {
  var worker = function worker(base, extension) {
    return (0, _reflection.isArray)(base) ? (0, _reflection.isArray)(extension) ? (base.push.apply(base, (0, _toConsumableArray2["default"])(extension)), base) : extension : ((0, _lib.keys)(extension).forEach(function (key) {
      var child = base[key];
      var childExtension = extension[key];
      base[key] = (0, _reflection.isIterable)(childExtension) ? (0, _reflection.isIterable)(child) ? worker(child, childExtension) // eslint-disable-next-line no-use-before-define
      // TODO: Check whether the clone is necessary.
      : clone(childExtension) : childExtension;
    }), base);
  };

  return function (base) {
    for (var _len = arguments.length, extensions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      extensions[_key - 1] = arguments[_key];
    }

    return extensions.forEach(function (extension) {
      return (0, _reflection.isIterable)(extension) && worker(base, clone(extension));
    }) || base;
  };
}();
/**
 * Merges multiple objects and their descendants with to the given base object.
 * When immutability is required, a shell could be passed as the base object.
 * @param {collection} base The base collection on which
 * the extensions would be merged to.
 * @param {...collection} extensions The extensions to be merged.
 */


exports.combine = combine;

var merge = function () {
  var worker = function worker(base, extension) {
    (0, _lib.keys)(extension).forEach(function (key) {
      var child = base[key];
      var childExtension = extension[key];
      base[key] = (0, _reflection.isIterable)(childExtension) ? (0, _reflection.isIterable)(child) ? worker(child, childExtension) // eslint-disable-next-line no-use-before-define
      // TODO: Check whether the clone is necessary.
      : clone(childExtension) : childExtension;
    });
    return base;
  };

  return function (base) {
    for (var _len2 = arguments.length, extensions = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      extensions[_key2 - 1] = arguments[_key2];
    }

    return extensions.forEach(function (extension) {
      return (0, _reflection.isIterable)(extension) && worker(base, extension);
    }) || base;
  };
}();
/**
 * Overlays multiple objects and their descendants with the given base object.
 * When immutability is required, a shell could be passed as the base object.
 * @param {collection} base The base collection on which
 * the extensions would be overlaid to.
 * @param {...collection} extensions The extensions to be overlaid.
 */


exports.merge = merge;

var overlay = function () {
  var worker = function worker(base, extension) {
    (0, _lib.keys)(extension).forEach(function (key) {
      var child = base[key];
      var childExtension = extension[key];
      base[key] = (0, _reflection.isDict)(childExtension) ? (0, _reflection.isDict)(child) ? worker(child, childExtension) // eslint-disable-next-line no-use-before-define
      // TODO: Check whether the clone is necessary.
      : clone(childExtension) : childExtension;
    });
    return base;
  };

  return function (base) {
    for (var _len3 = arguments.length, extensions = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      extensions[_key3 - 1] = arguments[_key3];
    }

    return extensions.forEach(function (extension) {
      return (0, _reflection.isIterable)(extension) && worker(base, extension);
    }) || base;
  };
}(); // TODO: Maintain the key order, similar to merge.

/**
 * Fills the missing properties of the given base from those of the extensions.
 * @param {collection} base The base collection on which
 * the extensions would be filled.
 * @param {...collection} extensions The extensions with properties to fill.
 */


exports.overlay = overlay;

var fill = function fill(base) {
  for (var _len4 = arguments.length, extensions = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    extensions[_key4 - 1] = arguments[_key4];
  }

  return merge(base, merge.apply(void 0, [{}].concat((0, _toConsumableArray2["default"])(extensions.reverse()), [base])));
}; // Merges an array of objects / object-arrays into a single object.


exports.fill = fill;

var squash = function squash() {
  for (var _len5 = arguments.length, objects = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    objects[_key5] = arguments[_key5];
  }

  return assign.apply(void 0, [{}].concat((0, _toConsumableArray2["default"])(objects.reduce(function (aggregate, value) {
    return [].concat((0, _toConsumableArray2["default"])(aggregate), (0, _toConsumableArray2["default"])(wrapAsArray(value)));
  }, []))));
};
/**
 * Retrieves the value, notified by a path, from a nested map.
 * Slashes are used as the separator for readability.
 * Starting paths with a slash yields better accuracy.
 * @param {collection} obj The collection to look into.
 * @param {string} path The path to look for. Slash is the separator.
 * And backslash is the escape char.
 * @returns {*} The value from the path or undefined.
 */


exports.squash = squash;

var result = function result(obj, path) {
  var pathParts = map((0, _path.parts)((0, _path.resolve)('/', path)), _path.unescape);
  var partCount = pathParts.length;
  var currentObject = obj;
  var cursor = 0;

  while (cursor < partCount && (0, _reflection.isDefined)(currentObject)) {
    currentObject = currentObject[pathParts[cursor++]];
  }

  return currentObject;
}; // Swaps the keys and values of a collection.


exports.result = result;

var flip = function flip(collection) {
  return reduce(collection, function (acc, value, key) {
    return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2["default"])({}, value, key));
  }, {});
};
/*
Converts a one-to-many map (an object of array values)
as an one-to-one inverted map, to ease reverse lookups.
IE: {'a': ['b', 'c']} => {'b': 'a', 'c': 'a'}.
*/


exports.flip = flip;

var flipMany = function flipMany(obj) {
  return reduce(obj, function (a, items, key) {
    return reduce(items, function (acc, item) {
      return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2["default"])({}, item, key));
    }, a);
  }, {});
};

exports.flipMany = flipMany;

var translate = function translate(source, selector) {
  return (// eslint-disable-next-line no-return-assign
    entries(selector).reduce(function (acc, _ref) {
      var _ref2 = (0, _slicedToArray2["default"])(_ref, 2),
          key = _ref2[0],
          value = _ref2[1];

      return acc[key] = (0, _reflection.isIterable)(value) ? translate(source, value) // eslint-disable-next-line no-sequences
      : result(source, value), acc;
    }, shell(selector))
  );
};

exports.translate = translate;

var compose = function compose() {
  for (var _len6 = arguments.length, objects = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    objects[_key6] = arguments[_key6];
  }

  var keysToPick = (0, _lib.keys)(objects[0]);
  var keysLength = keysToPick.length;
  return objects.reduce(function (aggregate, current) {
    var i = 0;

    while (i < keysLength) {
      var key = keysToPick[i++];
      var val = current[key];
      if (current.hasOwnProperty(key)) aggregate[key] = val;
    }

    return aggregate;
  }, {});
};

exports.compose = compose;

var patch = function patch(base, extension) {
  return sanitize(merge(clone(base), extension));
};

exports.patch = patch;

var diff = function diff(base, compared) {
  var difference = shell(base);
  (0, _lib.keys)(compared).forEach(function (key) {
    var baseChild = base[key];
    var comparedChild = compared[key];

    if (baseChild !== comparedChild) {
      difference[key] = (0, _reflection.isIterable)(comparedChild) && (0, _reflection.isIterable)(baseChild) ? diff(baseChild, comparedChild) : comparedChild;
    }
  });
  (0, _lib.keys)(base).forEach(function (key) {
    return compared[key] === undefined && (difference[key] = undefined);
  });
  return difference;
};

exports.diff = diff;

var secure = function secure(object) {
  return freeze(preventExtensions(seal(map(object, function (value) {
    return (0, _reflection.isIterable)(value) ? secure(value) : value;
  }))));
};

exports.secure = secure;

var contains = function contains(base, compared) {
  return (0, _reflection.isIterable)(base) && (0, _reflection.isIterable)(compared) ? (0, _lib.keys)(compared).findIndex(function (key) {
    return !contains(base[key], compared[key]);
  }) === -1 : base === compared;
};

exports.contains = contains;

var equals = function equals(base, compared) {
  return (0, _reflection.isIterable)(base) && (0, _reflection.isIterable)(compared) ? (0, _lib.keys)(base).length === (0, _lib.keys)(compared).length && (0, _lib.keys)(base).findIndex(function (key) {
    return !equals(base[key], compared[key]);
  }) === -1 : base === compared;
};
/* Tests the collections to have same children. */


exports.equals = equals;

var hasSame = function hasSame(base, compared) {
  return (0, _lib.keys)(base).length === (0, _lib.keys)(compared).length && findKey(base, function (value, key) {
    return value !== compared[key];
  }) === undefined;
};

exports.hasSame = hasSame;
var toArray = values;
exports.toArray = toArray;

var toDict = function toDict(collection) {
  return fromEntries(map(collection, function (value, key) {
    return [key, value];
  }));
};

exports.toDict = toDict;

var adopt = function adopt(base) {
  for (var _len7 = arguments.length, extensions = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
    extensions[_key7 - 1] = arguments[_key7];
  }

  return each(extensions, function (extension) {
    return each(extension, function (value, key) {
      return base[key] = value;
    });
  }) // eslint-disable-next-line no-sequences
  , base;
};

exports.adopt = adopt;

var range = function range() {
  var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 9;
  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  return Array.from({
    length: sign(end - start) !== sign(step) || !step ? 0 : ceil(abs(end - start) / abs(step))
  }, function (dummy, i) {
    return i * step + start;
  });
};

exports.range = range;

var length = function length(collection) {
  return ((0, _reflection.isArray)(collection) ? collection : (0, _lib.keys)(collection)).length;
};

exports.length = length;

var count = function count(collection) {
  return (0, _lib.keys)(collection).length;
};

exports.count = count;

var shares = function shares(left, right) {
  var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['id'];
  return length(filter(props, function (prop) {
    return left[prop] === right[prop];
  })) === props.length;
};

exports.shares = shares;

var shuffle = function shuffle(collection) {
  var ixs = (0, _lib.keys)(collection);
  var newIxs = [];

  while (ixs.length) {
    newIxs.push(ixs.splice((0, _lib.rndBetween)(0, ixs.length), 1)[0]);
  }

  return newIxs.reduce((0, _reflection.isArray)(collection) // eslint-disable-next-line no-return-assign
  ? function (t, c, i // eslint-disable-next-line no-sequences
  ) {
    return t[i] = collection[c], t;
  } // eslint-disable-next-line no-return-assign
  : function (t, c) {
    return t[c] = collection[c], t;
  }, shell(collection));
};

exports.shuffle = shuffle;

var sort = function sort(collection) {
  var sorter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _sorters.ascending;
  return (0, _reflection.isArray)(collection) ? collection.slice().sort(sorter) : fromEntries(entries(collection).sort(function (a, b) {
    return sorter(a[1], b[1]);
  }));
};

exports.sort = sort;

var flatMap = function flatMap(collection) {
  return walk(collection, function (digest, value) {
    var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    return _objectSpread((0, _defineProperty2["default"])({}, "".concat(key, "/"), value), (0, _reflection.isDefined)(digest) ? reduce(digest, function (acc, childDigest) {
      return reduce(childDigest, function (accOne, val, childPath) {
        accOne["".concat(key, "/").concat(childPath)] = val;
        return accOne;
      }, acc);
    }, {}) : {});
  });
};

exports.flatMap = flatMap;