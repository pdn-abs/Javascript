"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _collection = require("@laufire/utils/collection");

var _random = require("@laufire/utils/random");

var _reducers = require("@laufire/utils/reducers");

var _prob = require("./prob");

var _helpers = require("../test/helpers");

var _path = require("./path");

// TODO: Use published import when available.

/* Config */
var higherLimit = 8;
var lowerLimit = 0; // TODO: Use rndRange from helpers.

var getRndRange = function getRndRange() {
  return (0, _collection.range)(0, (0, _random.rndBetween)(lowerLimit, higherLimit));
};

var navMarkers = ['.', '/'];
var escapeChar = '\\';
var specialChars = [].concat(navMarkers, [escapeChar]);
var escapedChars = (0, _collection.map)(specialChars, function (_char) {
  return "\\".concat(_char);
});
var labelChars = [].concat((0, _toConsumableArray2["default"])('abcdefghijklmnopqrstuvwxyz'.split('')), (0, _toConsumableArray2["default"])(escapedChars));

var rndChars = function rndChars(collection) {
  return (0, _collection.shuffle)((0, _random.rndValues)(collection, (0, _random.rndBetween)(1, 8)));
};

var partGenerators = {
  relative: function relative() {
    return '.'.repeat((0, _random.rndBetween)(1, 5));
  },
  empty: function empty() {
    return '';
  },
  label: function label() {
    return rndChars(labelChars).join('');
  }
};

var randomParts = function randomParts() {
  return (0, _collection.map)(getRndRange(), function () {
    return (0, _random.rndValue)(partGenerators)();
  });
};

var matchers = {
  relative: /^\.+$/,
  empty: /^$/,
  label: /(?:[^\\/\\]|\\.)+/
};

var getPartType = function getPartType(part) {
  return (0, _collection.findKey)(matchers, function (matcher) {
    return matcher.test(part);
  });
};

var isLabel = function isLabel(part) {
  return getPartType(part) === 'label';
};

var fixers = {
  absolute: {
    partFixer: function partFixer(pathParts) {
      return pathParts;
    },
    pathFixer: function pathFixer(pathParts) {
      return pathParts.length ? '/' : '';
    },
    prefix: '/'
  },
  relative: {
    partFixer: function partFixer(pathParts) {
      return [partGenerators.relative()].concat((0, _toConsumableArray2["default"])(pathParts));
    },
    pathFixer: function pathFixer() {
      return '';
    },
    prefix: './'
  }
};

var toLax = function () {
  var prefixProbs = {
    should: {
      qualifier: function qualifier(source, type) {
        return type === 'absolute' || source.length === 0 || source[0] === '';
      },
      value: 1
    },
    shouldNot: {
      qualifier: function qualifier(_ref, type) {
        var _ref2 = (0, _slicedToArray2["default"])(_ref, 1),
            firstPart = _ref2[0];

        return type === 'relative' && getPartType(firstPart) === 'relative';
      },
      value: 0
    },
    optional: {
      qualifier: function qualifier(_ref3, type) {
        var _ref4 = (0, _slicedToArray2["default"])(_ref3, 1),
            firstPart = _ref4[0];

        return type === 'relative' && isLabel(firstPart);
      },
      value: 0.5
    }
  };
  var segments = {
    prefix: function prefix(source, type) {
      var prefix = fixers[type].prefix;

      var _find = (0, _collection.find)(prefixProbs, function (_ref5) {
        var qualifier = _ref5.qualifier;
        return qualifier(source, type);
      }),
          prob = _find.value;

      return "".concat((0, _prob.isProbable)(prob) ? prefix : '');
    },
    body: function body(source) {
      return source.join('/');
    },
    suffix: function suffix(source) {
      var prob = source[source.length - 1] === '' ? 1 : source.length ? 0.5 : 0;
      return "".concat((0, _prob.isProbable)(prob) ? '/' : '');
    }
  };
  return function (source, type) {
    return (0, _collection.reduce)(segments, function (acc, segment) {
      return acc + segment(source, type);
    }, '');
  };
}();

var fixParts = function fixParts(source, fixedType) {
  return [].concat((0, _toConsumableArray2["default"])(fixedType === 'lax' && isLabel(source[0]) ? ['.'] : []), (0, _toConsumableArray2["default"])(source));
};

var generateCase = function generateCase() {
  var weights = {
    absolute: 1,
    relative: 3
  };
  var fixedType = (0, _random.rndValueWeighted)(weights)();
  var isLax = (0, _prob.isProbable)(0.5);
  var _fixers$fixedType = fixers[fixedType],
      partFixer = _fixers$fixedType.partFixer,
      pathFixer = _fixers$fixedType.pathFixer;
  var source = partFixer(randomParts());
  var fixed = "".concat(pathFixer(source)).concat(source.join('/'), "/");
  var fixedParts = fixParts(source, fixedType);
  var path = isLax ? toLax(source, fixedType) : fixed;
  var type = fixed !== path ? 'lax' : fixedType;
  return {
    type: type,
    fixedType: fixedType,
    parts: source,
    fixedParts: fixedParts,
    path: path,
    fixed: fixed
  };
};

describe('path', function () {
  var generatedCases = (0, _helpers.retry)(generateCase, 10000);

  var testCases = function testCases(fn, cases) {
    return (0, _collection.map)(cases, function (_ref6) {
      var input = _ref6.input,
          expectation = _ref6.expectation;
      expect(fn(input)).toEqual(expectation);
    });
  };

  describe('Generated cases', function () {
    test('Parts length is from 0 to' + ' one more than higherLimit', function () {
      // NOTE: Length is one more than higherLimit due relative partFixer.
      var items = (0, _collection.map)(generatedCases, function (_ref7) {
        var length = _ref7.parts.length;
        return length;
      }); // TODO: Use library functions post publish.

      var lengths = (0, _toConsumableArray2["default"])(new Set(items)).sort(); // TODO: Change the values after using published rndBetween.
      // NOTE: Published rndBetween will be exclusive.

      var expectation = (0, _collection.range)(lowerLimit, higherLimit + 2);
      expect(lengths).toEqual(expectation);
    });
    test('All types of paths are present', function () {
      var validTypes = ['absolute', 'relative', 'lax'];
      var types = (0, _collection.pick)(generatedCases, 'type');
      var allTypes = (0, _collection.filter)(validTypes, function (validType) {
        return types.includes(validType);
      });
      expect(allTypes).toEqual(validTypes);
    });
    test('All part types are present', function () {
      var flattenedParts = (0, _collection.reduce)(generatedCases, function (acc, _ref8) {
        var currentParts = _ref8.parts;
        return [].concat((0, _toConsumableArray2["default"])(acc), (0, _toConsumableArray2["default"])(currentParts));
      }, []);
      var summary = (0, _helpers.summarize)((0, _collection.map)(flattenedParts, getPartType));
      var knownTypeCount = (0, _collection.reduce)(summary, _reducers.sum, 0);
      expect(knownTypeCount).toEqual(flattenedParts.length);
      expect(summary.undefined).toEqual(undefined);
    });
    test('Ratio between absolute and relative paths is 1:3', function () {
      var allTypes = (0, _collection.pick)(generatedCases, 'fixedType');
      (0, _helpers.testRatios)(allTypes, {
        absolute: 1 / 4,
        relative: 3 / 4
      });
    });
  });
  describe('fix fixes the given path', function () {
    test('example', function () {
      var cases = [{
        input: '/a/b',
        expectation: '/a/b/'
      }, {
        input: 'a/b',
        expectation: './a/b/'
      }, {
        input: './a/b/',
        expectation: './a/b/'
      }, {
        input: 0,
        expectation: './0/'
      }];
      testCases(_path.fix, cases);
    });
    test('randomized test', function () {
      (0, _collection.map)(generatedCases, function (_ref9) {
        var path = _ref9.path,
            fixed = _ref9.fixed;
        expect((0, _path.fix)(path)).toEqual(fixed);
      });
    });
  });
  describe('parts splits the given path into parts array', function () {
    test('example', function () {
      var cases = [{
        input: '/a/b/',
        expectation: ['a', 'b']
      }, {
        input: './a/b//',
        expectation: ['.', 'a', 'b', '']
      }, {
        input: 'a/b',
        expectation: ['.', 'a', 'b']
      }];
      testCases(_path.parts, cases);
    });
    test('randomized test', function () {
      (0, _collection.map)(generatedCases, function (_ref10) {
        var path = _ref10.path,
            expected = _ref10.parts;
        expect((0, _path.parts)(path)).toEqual(expected);
      });
    });
  });
  describe('pathType identifies the path type of the given path', function () {
    test('example', function () {
      var cases = [{
        input: '/a/b/',
        expectation: 'absolute'
      }, {
        input: './a/b/',
        expectation: 'relative'
      }, {
        input: './a/b',
        expectation: 'lax'
      }, {
        input: 'a/b/',
        expectation: 'lax'
      }];
      testCases(_path.pathType, cases);
    });
    test('randomized test', function () {
      (0, _collection.map)(generatedCases, function (_ref11) {
        var path = _ref11.path,
            expected = _ref11.type;
        expect((0, _path.pathType)(path)).toEqual(expected);
      });
    });
  });
  describe('resolve resolves a valid path from the given paths', function () {
    test('example', function () {
      var cases = [{
        input: '/a/b/',
        expectation: '/a/b/'
      }, {
        input: '/a/.../',
        expectation: undefined
      }, {
        input: './a//b/../',
        expectation: './a//'
      }, {
        input: './a/.../b/',
        expectation: '../b/'
      }, {
        input: '/.a/b./',
        expectation: '/.a/b./'
      }];
      testCases(_path.resolve, cases);
    });
    test('randomized test', function () {
      var digest = function digest(typeParts, isAbsolute) {
        var pending = 0;
        var labels = [];

        var navigate = function navigate(part) {
          pending += Math.max(0, part.length - labels.length - 1);
          labels.splice(1 - part.length || labels.length);
        };

        (0, _collection.map)(typeParts, function (part) {
          return getPartType(part) !== 'relative' ? labels.push(part) : navigate(part);
        });
        var body = "".concat(labels.join('/')).concat(labels.length ? '/' : '');
        var prefix = "".concat('.'.repeat(pending + (isAbsolute ? 0 : 1)), "/");
        var resolved = "".concat(prefix).concat(body);
        return {
          pending: pending,
          labels: labels,
          resolved: resolved
        };
      };

      var buildExpectation = function buildExpectation(cases) {
        var lastAbsIndex = (0, _helpers.findLastIndex)(cases, function (_ref12) {
          var fixedType = _ref12.fixedType;
          return fixedType === 'absolute';
        });
        var isAbsolute = lastAbsIndex > -1;
        var sliced = cases.slice(isAbsolute ? lastAbsIndex : 0);
        var typeParts = (0, _collection.map)(sliced, function (_ref13) {
          var currentParts = _ref13.parts;
          return currentParts;
        }).flat();

        var _digest = digest(typeParts, isAbsolute),
            pending = _digest.pending,
            resolved = _digest.resolved;

        return lastAbsIndex > -1 && pending > 0 ? undefined : resolved;
      };

      (0, _helpers.retry)(function () {
        var cases = (0, _helpers.retry)(generateCase, (0, _random.rndBetween)(0, 10));
        var expected = buildExpectation(cases);
        var paths = (0, _collection.pick)(cases, 'path');

        var result = _path.resolve.apply(void 0, (0, _toConsumableArray2["default"])(paths));

        expect(result).toEqual(expected);
      });
    });
  });
  describe('escaping and unescaping', function () {
    var inputs = (0, _helpers.retry)(function () {
      return rndChars([].concat((0, _toConsumableArray2["default"])(labelChars), (0, _toConsumableArray2["default"])(specialChars), (0, _toConsumableArray2["default"])(escapedChars)));
    });
    var cases = (0, _collection.map)(inputs, function (characters) {
      var input = characters.join('');
      var escaped = (0, _collection.map)(characters, function (character) {
        return character.split('').map(function (item) {
          return specialChars.includes(item) ? "".concat(escapeChar).concat(item) : item;
        }).join('');
      }).join('');
      var unescaped = input.split(escapeChar.repeat(2)).map(function (part) {
        return part.split(escapeChar).join('');
      }).join(escapeChar);
      return {
        input: input,
        escaped: escaped,
        unescaped: unescaped
      };
    });
    describe('escape escapes the given path', function () {
      test('example', function () {
        var escapeCases = [{
          input: 'a.',
          expectation: 'a\\.'
        }, {
          input: 'a\\b/',
          expectation: 'a\\\\b\\/'
        }, {
          input: 'a./\\',
          expectation: 'a\\.\\/\\\\'
        }];
        testCases(_path.escape, escapeCases);
      });
      test('randomized test', function () {
        (0, _collection.map)(cases, function (_ref14) {
          var input = _ref14.input,
              escaped = _ref14.escaped;
          var result = (0, _path.escape)(input);
          expect(result).toEqual(escaped);
        });
      });
    });
    describe('unescape unescapes the given path', function () {
      test('example', function () {
        var unescapeCases = [{
          input: 'a\\.',
          expectation: 'a.'
        }, {
          input: 'a\\\\b\\/',
          expectation: 'a\\b/'
        }, {
          input: 'a\\.\\/\\\\',
          expectation: 'a./\\'
        }];
        testCases(_path.unescape, unescapeCases);
      });
      test('randomized test', function () {
        (0, _collection.map)(cases, function (_ref15) {
          var input = _ref15.input,
              unescaped = _ref15.unescaped;
          var result = (0, _path.unescape)(input);
          expect(result).toEqual(unescaped);
        });
      });
    });
  });
});