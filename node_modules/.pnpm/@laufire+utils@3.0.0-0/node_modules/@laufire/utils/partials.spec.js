"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _random = require("@laufire/utils/random");

var _helpers = require("../test/helpers");

var _partials = require("./partials");

test('translate returns a partial to access values of collections', function () {
  var key = (0, _random.rndString)();
  var number = (0, _helpers.rndNumber)();
  var map = (0, _defineProperty2["default"])({}, key, number);
  var translator = (0, _partials.translate)(map);
  expect(translator(key)).toEqual(number);
});
describe('partial returns a partially provisioned function, ' + 'which could be called with remaining data.', function () {
  var numOne = (0, _helpers.rndNumber)();
  var numTwo = (0, _helpers.rndNumber)();
  var numThree = (0, _helpers.rndNumber)();
  var numFour = (0, _helpers.rndNumber)();
  test('arrays are used for positional arguments', function () {
    var sum = function sum(a, b) {
      return a + b;
    };

    var withoutBValue = (0, _partials.partial)(sum, [numOne]);
    var withoutAValue = (0, _partials.partial)(sum, [undefined, numThree]);
    expect(withoutBValue(numTwo)).toEqual(numOne + numTwo);
    expect(withoutAValue(numFour)).toEqual(numThree + numFour);
  });
  test('objects are used for named arguments', function () {
    var sum = function sum(_ref) {
      var a = _ref.a,
          b = _ref.b;
      return a + b;
    };

    var simple = (0, _partials.partial)(sum, {
      a: numOne
    });
    var overridden = (0, _partials.partial)(sum, {
      a: numOne - (0, _helpers.rndNumber)()
    });
    expect(simple({
      b: numTwo
    })).toEqual(numOne + numTwo);
    expect(overridden({
      a: numThree,
      b: numFour
    })).toEqual(numThree + numFour);
  });
});