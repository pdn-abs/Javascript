"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _collection = require("@laufire/utils/collection");

var _random = require("@laufire/utils/random");

var _reflection = require("@laufire/utils/reflection");

var _helpers = require("../test/helpers");

var _sorters = require("./sorters");

/* Helpers */

/* Tested */

/* Spec */
describe('Sorters', function () {
  var getRndCollection = function getRndCollection() {
    var number = (0, _helpers.rndNumber)();
    return (0, _collection.secure)((0, _collection.map)((0, _helpers.rndCollection)(), function () {
      return number++;
    }));
  };

  var reversers = {
    array: function array(_array) {
      return (0, _collection.clone)(_array).reverse();
    },
    object: function object(_object) {
      var randomCollection = _object;
      var reversedKeys = (0, _collection.keys)(randomCollection).reverse();
      return (0, _collection.reduce)(reversedKeys, function (acc, key) {
        acc[key] = randomCollection[key];
        return acc;
      }, (0, _collection.shell)(randomCollection));
    }
  };
  /* Tests */

  describe('ascending sorts the given collection in' + ' ascending order', function () {
    test('example', function () {
      var input = [2, 3, 1];
      var expected = [1, 2, 3];
      expect((0, _collection.sort)((0, _collection.shuffle)(input), _sorters.ascending)).toEqual(expected);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var collection = getRndCollection();
        var input = (0, _collection.shuffle)(collection);
        expect((0, _collection.sort)(input, _sorters.ascending)).toEqual(collection);
      });
    });
  });
  describe('descending sorts the given collection in' + ' descending order', function () {
    test('example', function () {
      var input = [2, 1, 3];
      var expected = [3, 2, 1];
      expect((0, _collection.sort)((0, _collection.shuffle)(input), _sorters.descending)).toEqual(expected);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var collection = getRndCollection();
        var expected = reversers[(0, _reflection.inferType)(collection)](collection);
        var input = (0, _collection.shuffle)(collection);
        expect((0, _collection.sort)(input, _sorters.descending)).toEqual(expected);
      });
    });
  });
  describe('existing preserves the existing order' + ' of the given collection', function () {
    test('example', function () {
      var input = [2, 1, 3];
      expect((0, _collection.sort)(input, _sorters.existing)).toEqual(input);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var collection = getRndCollection();
        var input = (0, _collection.shuffle)(collection);
        expect((0, _collection.sort)(input, _sorters.existing)).toEqual(input);
      });
    });
  });
  describe('reverse reverses the given collection', function () {
    test('example', function () {
      var input = [1, 3, 2];
      var expected = [2, 3, 1];
      expect((0, _collection.sort)(input, _sorters.reverse)).toEqual(expected);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var collection = getRndCollection();
        var input = (0, _collection.shuffle)(collection);
        var expected = reversers[(0, _reflection.inferType)(input)](input);
        expect((0, _collection.sort)(input, _sorters.reverse)).toEqual(expected);
      });
    });
  });
  describe('onProp sorts the given collection with the given sorter' + ' on a given property', function () {
    test('example', function () {
      var inputs = [{
        a: 3
      }, {
        a: 1
      }, {
        a: 2
      }];
      var expected = [{
        a: 1
      }, {
        a: 2
      }, {
        a: 3
      }];
      expect((0, _collection.sort)(inputs, (0, _sorters.onProp)('a', _sorters.ascending))).toEqual(expected);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var collection = (0, _helpers.similarCols)();
        var rndProp = (0, _helpers.rndKey)((0, _random.rndValue)(collection));
        var sorter = (0, _random.rndValue)([_sorters.ascending, _sorters.descending]);
        var count = 0;
        var expected = (0, _collection.map)(collection, function (result) {
          return (0, _collection.merge)((0, _collection.clone)(result), (0, _defineProperty2["default"])({}, rndProp, sorter === _sorters.ascending ? ++count : --count));
        });
        var input = (0, _collection.secure)((0, _collection.shuffle)(expected));
        expect((0, _collection.sort)(input, (0, _sorters.onProp)(rndProp, sorter))).toEqual(expected);
      });
    });
  });
  describe('compile helps in sorting collection of collections', function () {
    describe('compile works with multiple props,' + ' with descending priority', function () {
      test('example', function () {
        var input = [{
          name: 'guava',
          price: 10
        }, {
          name: 'guava',
          price: 5
        }, {
          name: 'apple',
          price: 5
        }];
        var expected = [{
          name: 'apple',
          price: 5
        }, {
          name: 'guava',
          price: 10
        }, {
          name: 'guava',
          price: 5
        }];
        var config = {
          name: 'ascending',
          price: 'descending'
        };
        expect((0, _collection.sort)(input, (0, _sorters.compile)(config))).toEqual(expected);
      });
      test('randomized test', function () {
        (0, _helpers.retry)(function () {
          var _shuffle;

          var collections = (0, _helpers.similarCols)();

          var _rndKeys = (0, _helpers.rndKeys)((0, _random.rndValue)(collections), 2),
              _rndKeys2 = (0, _slicedToArray2["default"])(_rndKeys, 2),
              ascendingKey = _rndKeys2[0],
              descendingKey = _rndKeys2[1];

          var config = (0, _collection.secure)((0, _collection.shuffle)((_shuffle = {}, (0, _defineProperty2["default"])(_shuffle, ascendingKey, 'ascending'), (0, _defineProperty2["default"])(_shuffle, descendingKey, 'descending'), _shuffle)));

          var _keys = (0, _collection.keys)(config),
              _keys2 = (0, _slicedToArray2["default"])(_keys, 2),
              firstKey = _keys2[0],
              secondKey = _keys2[1];

          var counters = {
            ascending: 0,
            descending: 0
          };

          var updateCounter = function updateCounter(key) {
            return key === 'ascending' ? counters.ascending++ : counters.descending--;
          };

          var expected = (0, _collection.map)(collections, function (collection) {
            var _merge2;

            (0, _random.rndValue)([0, 1]) && updateCounter(config[firstKey]);
            updateCounter(config[secondKey]);
            return (0, _collection.merge)((0, _collection.clone)(collection), (_merge2 = {}, (0, _defineProperty2["default"])(_merge2, firstKey, counters[config[firstKey]]), (0, _defineProperty2["default"])(_merge2, secondKey, counters[config[secondKey]]), _merge2));
          });
          var input = (0, _collection.secure)((0, _collection.shuffle)(expected));
          expect((0, _collection.sort)(input, (0, _sorters.compile)(config))).toEqual(expected);
        });
      });
    });
    test('compile supports custom grammars', function () {
      var products = [{
        name: 'banana',
        price: 1
      }, {
        name: 'apple',
        price: 1
      }, {
        name: 'apple',
        price: 3
      }];
      var expected = [{
        name: 'apple',
        price: 1
      }, {
        name: 'apple',
        price: 3
      }, {
        name: 'banana',
        price: 1
      }];
      var grammar = (0, _collection.secure)({
        customSort: _sorters.ascending
      });
      var config = (0, _collection.secure)({
        name: 'ascending',
        price: 'customSort'
      });
      expect((0, _collection.sort)(products, (0, _sorters.compile)(config, grammar))).toEqual(expected);
    });
    test('compile works with two dimensional arrays', function () {
      var input = [[3, 1], [2, 2], [2, 3]];
      var expected = [[2, 3], [2, 2], [3, 1]];
      var config = (0, _collection.secure)(['ascending', 'descending']);
      expect((0, _collection.sort)(input, (0, _sorters.compile)(config))).toEqual(expected);
    });
  });
});