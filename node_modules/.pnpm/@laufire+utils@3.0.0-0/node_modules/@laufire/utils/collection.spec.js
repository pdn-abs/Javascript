"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _helpers = require("../test/helpers");

var _random = require("@laufire/utils/random");

var _reflection = require("@laufire/utils/reflection");

var _sorters = require("@laufire/utils/sorters");

var _reducers = require("@laufire/utils/reducers");

var _collection = require("@laufire/utils/collection");

var _predicates = require("@laufire/utils/predicates");

var _collection2 = require("./collection");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var mockObj = function mockObj(objKeys, value) {
  return (0, _collection2.fromEntries)((0, _collection2.map)(objKeys, function (key) {
    return [key, (0, _reflection.isDefined)(value) ? value : key];
  }));
};
/* Spec */


describe('Collection', function () {
  /* Mocks and Stubs */
  var simpleObj = (0, _collection2.secure)({
    a: 1,
    b: 2
  });
  var simpleArray = (0, _collection2.secure)([1, 2]);
  var nestedObj = (0, _collection2.secure)({
    a: 1,
    b: 2,
    c: {
      d: {
        e: 5
      }
    }
  });
  var complexArray = (0, _collection.secure)([{
    innerArray: [1, 3],
    dirtyArray: [undefined, 1]
  }]);
  var complexObject = (0, _collection2.secure)({
    single: 'single',
    parent: {
      'child': {
        grandChild: 'grandChild'
      },
      '/unescaped/child': 'unescaped/child',
      'escaped\\/child': 'escaped\\/child'
    },
    undefinedProp: undefined,
    array: (0, _collection2.clone)(simpleArray),
    primitiveOverlay: null,
    iterableOverlay: null,
    complexArray: complexArray
  });
  var baseObject = (0, _collection2.secure)({
    a: 1,
    b: 2,
    c: 1,
    d: 'only in base',
    e: [0]
  });
  var comparedObject = (0, _collection2.secure)({
    a: 1,
    b: 3,
    c: {
      d: 3
    },
    e: [0, 1],
    f: 'only in compared'
  });
  /* Helpers */

  var stitch = function stitch(val, key) {
    return String(key) + String(val);
  };

  var reverseArray = function reverseArray(input) {
    return (0, _collection2.sort)(input, _sorters.reverse);
  };

  var testForArguments = function testForArguments(fn, collection) {
    // TODO: Use imported nothing after publishing.
    var mockPredicate = jest.fn(function () {
      return false;
    });
    fn(collection, mockPredicate); // TODO: Use imported Keys after publishing.

    (0, _collection.map)((0, _collection2.keys)(collection), function (key) {
      return expect(mockPredicate).toHaveBeenCalledWith(collection[key], key, collection);
    });
  };

  var testIterator = function testIterator(_ref) {
    var fn = _ref.fn,
        processor = _ref.processor,
        data = _ref.data;
    (0, _collection.entries)(data).map(function (_ref2) {
      var _ref3 = (0, _slicedToArray2["default"])(_ref2, 2),
          dummy = _ref3[0],
          _ref3$ = (0, _slicedToArray2["default"])(_ref3[1], 2),
          collection = _ref3$[0],
          expectation = _ref3$[1];

      return expect(fn(collection, processor)).toEqual(expectation);
    });
    testForArguments(fn, data);
  };

  var arrayOrObject = function arrayOrObject(collection) {
    return (0, _random.rndValue)([_collection.values, _helpers.toObject])(collection);
  };

  var convey = function convey() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return args;
  };

  var getUnlike = function () {
    var unlikeGenerator = function unlikeGenerator(value) {
      var unlike = (0, _helpers.rnd)();
      return value !== unlike ? unlike : unlikeGenerator(value);
    };

    return function (value) {
      return (0, _reflection.isIterable)(value) ? (0, _helpers.randomValues)(value, (0, _collection.keys)(value).length - 1) : unlikeGenerator(value);
    };
  }();

  var symbolize = function symbolize(iterable) {
    return (0, _collection.map)(iterable, function (dummy, key) {
      return Symbol(key);
    });
  };

  var testMerge = function testMerge(merged) {
    for (var _len2 = arguments.length, collections = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      collections[_key2 - 1] = arguments[_key2];
    }

    (0, _collection.map)(merged, function (value, key) {
      // TODO: Use library filter.
      var getChildren = function getChildren() {
        return (0, _collection.map)(collections.filter(function (collection) {
          return (0, _reflection.isIterable)(collection) && Object.hasOwnProperty(collection, key);
        }), function (child) {
          return child[key];
        });
      };

      var expected = getChildren();
      (0, _reflection.isIterable)(value) ? testMerge.apply(void 0, [value].concat((0, _toConsumableArray2["default"])(getChildren()))) : (0, _helpers.expectEquals)(value, expected[expected.length - 1]);
    });
  };
  /* Tests */


  describe('map transforms the given iterable using' + ' the given callback', function () {
    describe('examples', function () {
      test('map works with all the properties of the object' + ' and builds a new object', function () {
        expect((0, _collection2.map)(simpleObj, stitch)).toEqual({
          a: 'a1',
          b: 'b2'
        });
      });
      test('map handles arrays with keys instead of indexes', function () {
        expect((0, _collection2.map)([1, 2], stitch)).toEqual(['01', '12']);
      });
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var fn = _collection2.map;
        var collection = (0, _helpers.rndCollection)();
        var expectation = symbolize(collection);

        var processor = function processor(dummy, key) {
          return expectation[key];
        };

        var data = [[collection, expectation]];
        testIterator({
          fn: fn,
          processor: processor,
          data: data
        });
      });
    });
  });
  describe('filter filters the given iterable using' + ' the given callback', function () {
    test('example', function () {
      expect((0, _collection2.filter)(simpleObj, (0, _predicates.isEqual)(1))).toEqual({
        a: 1
      });
      expect((0, _collection2.filter)(simpleArray, (0, _predicates.isEqual)(1))).toEqual([1]);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var fn = _collection2.filter;
        var collection = (0, _helpers.rndCollection)();
        var keysToBeFiltered = (0, _helpers.rndKeys)(collection);

        var processor = function processor(dummy, key) {
          return keysToBeFiltered.includes(key);
        };

        var expectation = (0, _collection.clean)((0, _collection.select)(collection, keysToBeFiltered));
        var data = [[collection, expectation]];
        testIterator({
          fn: fn,
          processor: processor,
          data: data
        });
      });
    });
  });
  describe('find finds the first element from the collection chose' + ' by the predicate', function () {
    test('example', function () {
      expect((0, _collection2.find)(simpleObj, (0, _predicates.isEqual)(2))).toBe(2);
      expect((0, _collection2.find)(simpleObj, (0, _predicates.isEqual)(3))).toBeUndefined();
      expect((0, _collection2.find)(simpleArray, (0, _predicates.isEqual)(2))).toBe(2);
      expect((0, _collection2.find)(simpleArray, (0, _predicates.isEqual)(3))).toBeUndefined();
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var fn = _collection2.find;
        var collection = (0, _helpers.rndCollection)();
        var needle = (0, _random.rndValue)(collection);
        var processor = (0, _predicates.isEqual)(needle);
        var data = [[collection, needle]];
        testIterator({
          fn: fn,
          processor: processor,
          data: data
        });
      });
    });
  });
  describe('findLast finds the last element from the collection chose' + ' by the predicate', function () {
    test('example', function () {
      var iterable = [999, 12, 8, 130, 44];
      expect((0, _collection2.findLast)(iterable, (0, _predicates.isEqual)(44))).toEqual(44);
      expect((0, _collection2.findLast)(iterable, (0, _predicates.isEqual)(1000))).toEqual(undefined);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var collection = (0, _helpers.rndCollection)();
        var needle = (0, _random.rndValue)(collection);
        var expectations = [[needle, needle], [Symbol('value'), undefined]];
        (0, _collection.map)(expectations, function (_ref4) {
          var _ref5 = (0, _slicedToArray2["default"])(_ref4, 2),
              value = _ref5[0],
              expectation = _ref5[1];

          var fn = _collection2.findLast;
          var processor = (0, _predicates.isEqual)(value);
          var data = [[collection, expectation]];
          testIterator({
            fn: fn,
            processor: processor,
            data: data
          });
        });
      });
    });
  });
  test('lFind is an alias for findLast', function () {
    expect(_collection2.lFind).toEqual(_collection2.findLast);
  });
  describe('findKey finds the key of first element from the collection chose' + ' by the predicate', function () {
    test('example', function () {
      expect((0, _collection2.findKey)(simpleObj, (0, _predicates.isEqual)(2))).toBe('b');
      expect((0, _collection2.findKey)(simpleObj, (0, _predicates.isEqual)(3))).toBeUndefined();
      expect((0, _collection2.findKey)(simpleArray, (0, _predicates.isEqual)(2))).toBe(1);
      expect((0, _collection2.findKey)(simpleArray, (0, _predicates.isEqual)(3))).toBeUndefined();
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var fn = _collection2.findKey;
        var collection = (0, _helpers.rndCollection)();
        var needle = (0, _helpers.rndKey)(collection);
        var processor = (0, _predicates.isEqual)(collection[needle]);
        var expectation = needle;
        var data = [[collection, expectation]];
        testIterator({
          fn: fn,
          processor: processor,
          data: data
        });
      });
    });
  });
  test('findIndex is an alias for findKey', function () {
    expect(_collection2.findIndex).toBe(_collection2.findKey);
  });
  describe('findLastKey find the key of last element from the' + ' collection chose by predicate', function () {
    test('example', function () {
      var iterable = [999, 12, 8, 44, 130, 44];
      expect((0, _collection2.findLastKey)(iterable, (0, _predicates.isEqual)(44))).toEqual(5);
      expect((0, _collection2.findLastKey)(iterable, (0, _predicates.isEqual)(1000))).toEqual(undefined);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var fn = _collection2.findLastKey;
        var baseCol = (0, _helpers.rndCollection)();
        var selector = (0, _helpers.rndKeys)(baseCol);
        var needle = Symbol('needle');
        var haystack = (0, _collection.map)(baseCol, function (value, key) {
          return selector.includes(_helpers.converters[(0, _reflection.inferType)(baseCol)](key)) ? needle : value;
        });
        var expectation = selector[selector.length - 1];
        var processor = (0, _predicates.isEqual)(needle);
        var data = [[haystack, expectation]];
        testIterator({
          fn: fn,
          processor: processor,
          data: data
        });
      });
    });
  });
  test('lFindKey is an alias for findLastKey', function () {
    expect(_collection2.lFindKey).toEqual(_collection2.findLastKey);
  });
  describe('reduce reduces the given collection.', function () {
    test('example', function () {
      expect((0, _collection2.reduce)(simpleObj, _reducers.sum, 0)).toEqual(3);
      expect((0, _collection2.reduce)(simpleArray, _reducers.product, 1)).toEqual(2);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var collection = (0, _helpers.rndCollection)();
        var initial = Symbol('initial');
        var collectionKeys = (0, _collection.keys)(collection);
        var accumlators = [initial].concat((0, _toConsumableArray2["default"])((0, _collection.map)(collectionKeys, Symbol)));
        var expectation = accumlators[accumlators.length - 1];
        var predicate = jest.fn().mockImplementation(function (dummy, dummyOne, key) {
          return accumlators[collectionKeys.findIndex(function (cKey) {
            return cKey === String(key);
          }) + 1];
        });
        expect((0, _collection2.reduce)(collection, predicate, initial)).toEqual(expectation);
        (0, _collection.map)(collectionKeys, function (key, i) {
          return expect(predicate.mock.calls[i]).toEqual([accumlators[i], collection[key], // TODO: Remove converters post publishing.
          _helpers.converters[(0, _reflection.inferType)(collection)](key), collection]);
        });
      });
    });
  });
  describe('reduceN reduce the given nested collection.', function () {
    test('example', function () {
      expect((0, _collection2.nReduce)({
        a: 2,
        b: {
          c: {
            d: 8
          }
        }
      }, _reducers.product, 1)).toEqual(16);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var obj = (0, _helpers.rndNested)();
        var initial = Symbol('initial');
        var acc = [initial];
        var reducer = jest.fn().mockImplementation(function (dummy, dummyOne, key) {
          var ret = Symbol(key);
          acc.push(ret);
          return ret;
        });
        var reduced = (0, _collection2.nReduce)(obj, reducer, initial);

        var testReduce = function testReduce(branch) {
          return (0, _collection.map)(branch, function (value, key) {
            return (0, _reflection.isIterable)(value) ? testReduce(value) : expect(reducer).toHaveBeenCalledWith(acc.shift(), value, // TODO: Remove converters post publishing.
            _helpers.converters[(0, _reflection.inferType)(branch)](key), branch);
          });
        };

        testReduce(obj);
        expect(reduced).toEqual(acc.shift());
      });
    });
  });
  describe('shell returns an empty container of the same type' + ' as the given iterable', function () {
    test('example', function () {
      expect((0, _collection2.shell)(simpleObj)).toEqual({});
      expect((0, _collection2.shell)(simpleArray)).toEqual([]);
    });
    test('randomized test', function () {
      expect((0, _collection2.shell)(_helpers.object)).toEqual({});
      expect((0, _collection2.shell)(_helpers.array)).toEqual([]);
    });
  });
  describe('clean removes undefined props from the given iterable', function () {
    test('example', function () {
      expect((0, _collection2.clean)(complexObject)).not.toHaveProperty('undefinedProperty');
      expect((0, _collection2.clean)([undefined, 1])).toEqual([1]);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var collection = (0, _helpers.rndCollection)(); // TODO: Use rndValues post publishing.

        var dirtyKeys = (0, _helpers.rndKeys)(collection);
        var dirtyCollection = (0, _collection.secure)((0, _collection.map)(collection, function (value, key) {
          return dirtyKeys.includes(key) ? undefined : value;
        }));
        var expectation = (0, _collection.filter)(dirtyCollection, _reflection.isDefined);
        expect((0, _collection2.clean)(dirtyCollection)).toEqual(expectation);
      });
    });
  });
  describe('sanitize removes undefined props recursively from the' + 'given iterable', function () {
    test('example', function () {
      var sanitized = (0, _collection2.sanitize)(complexObject);
      expect(sanitized).not.toHaveProperty('undefinedProperty');
      expect(sanitized.complexArray[0].dirtyArray).toEqual([1]);
    });
    test('randomized test', function () {
      var isSanitizeEqual = function isSanitizeEqual(base, sanitized) {
        return (0, _collection2.map)((0, _collection.clean)(base), function (value, key) {
          return (0, _reflection.isIterable)(value) ? isSanitizeEqual(value, sanitized[key]) : expect(value).toEqual(sanitized[key]);
        });
      };

      (0, _helpers.retry)(function () {
        var data = (0, _helpers.rndNested)();
        var sanitized = (0, _collection2.sanitize)(data);
        isSanitizeEqual(data, sanitized);
      });
    });
  });
  test('each is an alias for map', function () {
    expect(_collection2.map).toEqual(_collection2.each);
  });
  describe('traverse recursively traverses through a given object and' + ' builds a new object from its primitives', function () {
    test('example', function () {
      expect((0, _collection2.traverse)(nestedObj, stitch)).toEqual({
        a: 'a1',
        b: 'b2',
        c: {
          d: {
            e: 'e5'
          }
        }
      });
      expect((0, _collection2.traverse)(1, convey)).toEqual([1]);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var input = (0, _helpers.rnd)();

        var testTraversed = function testTraversed(base, traversed) {
          return (0, _reflection.isIterable)(base) ? (0, _collection.map)(base, function (value, key) {
            return (0, _reflection.isIterable)(value) ? testTraversed(value, traversed[key]) : expect(traversed[key]).toEqual([value, // TODO: Remove converters post publishing.
            _helpers.converters[(0, _reflection.inferType)(base)](key), base]);
          }) : expect(traversed).toEqual([base]);
        };

        var traversed = (0, _collection2.traverse)(input, convey);
        testTraversed(input, traversed);
      });
    });
  });
  describe('has tells whether the given iterable has the given value', function () {
    test('example', function () {
      expect((0, _collection2.has)(simpleObj, 1)).toEqual(true);
      expect((0, _collection2.has)(simpleArray, 1)).toEqual(true);
      expect((0, _collection2.has)(simpleObj, 0)).toEqual(false);
      expect((0, _collection2.has)(simpleArray, 0)).toEqual(false);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var iterable = (0, _helpers.rndCollection)();
        expect((0, _collection2.has)(iterable, (0, _random.rndValue)(iterable))).toEqual(true);
        expect((0, _collection2.has)(iterable, Symbol)).toEqual(false);
      });
    });
  });
  describe('hasKey tells whether the given iterable has' + ' the given key', function () {
    test('example', function () {
      var cart = {
        item: 'apple',
        price: 100
      };
      expect((0, _collection2.hasKey)(cart, 'item')).toEqual(true);
      expect((0, _collection2.hasKey)(cart, 'discount')).toEqual(false);
    });
    test('randomized test', function () {
      var iterables = (0, _helpers.iterableTypes)();

      var types = _objectSpread(_objectSpread({}, (0, _helpers.allTypes)()), iterables);

      (0, _collection.map)(types, function (type) {
        (0, _collection2.has)(iterables, type) && expect((0, _collection2.hasKey)(type, (0, _helpers.rndKey)(type))).toEqual(true);
        expect((0, _collection2.hasKey)(type, (0, _random.rndString)())).toEqual(false);
      });
    });
  });
  describe('walk recursively walks through a given object and' + ' returns the reduced value', function () {
    test('example', function () {
      var dirStructure = {
        a: 1,
        b: {
          c: 2
        }
      };
      var report = {
        type: 'dir',
        size: 3,
        children: {
          a: {
            type: 'file',
            size: 1
          },
          b: {
            type: 'dir',
            size: 2,
            children: {
              c: {
                type: 'file',
                size: 2
              }
            }
          }
        }
      };

      var walker = function walker(digest, value) {
        return !(0, _reflection.isDefined)(digest) ? {
          type: 'file',
          size: value
        } : {
          type: 'dir',
          size: (0, _collection.reduce)(digest, function (acc, _ref6) {
            var size = _ref6.size;
            return acc + size;
          }, 0),
          children: digest
        };
      };

      expect((0, _collection2.walk)(dirStructure, walker)).toEqual(report);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var input = (0, _helpers.rnd)();
        var walker = jest.fn().mockImplementation(convey);
        var walkedResult = (0, _collection2.walk)(input, walker);
        var results = (0, _collection.clone)((0, _collection.pick)(walker.mock.results, 'value'));

        var testWalk = function testWalk(compared, base) {
          var _expect;

          var walked = (0, _reflection.isIterable)(base) ? (0, _collection.map)(base, function (value, key) {
            (0, _reflection.isIterable)(value) && testWalk(compared[0][key], value, // TODO: Remove converters post publishing.
            _helpers.converters[(0, _reflection.inferType)(base)](key), base);
            return results.shift();
          }) : undefined;

          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
            rest[_key3 - 2] = arguments[_key3];
          }

          (_expect = expect(walker)).toHaveBeenCalledWith.apply(_expect, [walked, base].concat(rest));

          expect(compared).toEqual([walked, base].concat(rest));
        };

        testWalk(walkedResult, input);
      });
    });
  });
  describe('clone clones the given object', function () {
    test('example', function () {
      expect((0, _collection2.clone)(complexObject)).toEqual(complexObject);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var rndNestedObj = (0, _helpers.rndNested)();

        var testCloned = function testCloned(base, compared) {
          return !(0, _reflection.isIterable)(base) ? expect(compared).toEqual(base) : (0, _collection.map)(base, function (value, key) {
            return testCloned(value, compared[key]);
          });
        };

        var cloned = (0, _collection2.clone)(rndNestedObj);
        testCloned(rndNestedObj, cloned);
      });
    });
  });
  describe('squash squashes objects and object lists' + ' to a single object', function () {
    test('example', function () {
      var squashed = (0, _collection2.squash)({
        a: 1
      }, [{
        b: 2
      }], {
        c: 3
      });
      expect(squashed).toEqual({
        a: 1,
        b: 2,
        c: 3
      });
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var objectArray = (0, _collection2.values)((0, _helpers.rndNested)(2, 2, ['object']));
        var propsToBeAltered = (0, _helpers.rndKeys)(objectArray);
        var inputs = (0, _collection.map)(objectArray, function (value, key) {
          return propsToBeAltered.includes(Number(key)) ? (0, _collection2.values)((0, _helpers.rndNested)(1, 2, ['object'])) : value;
        });
        var expectation = (0, _collection.reduce)(inputs.flat(), function (acc, val) {
          return _objectSpread(_objectSpread({}, acc), val);
        }, {});

        var squashed = _collection2.squash.apply(void 0, (0, _toConsumableArray2["default"])(inputs));

        expect(squashed).toEqual(expectation);
      });
    });
  });
  describe('merge merges multiple objects into one', function () {
    test('example', function () {
      var inputs = [{
        a: 1,
        c: 3,
        d: [1, 2, 3],
        e: [5]
      }, {
        b: 2,
        c: 4,
        d: [4, 5],
        e: [6, 7]
      }];
      var expected = {
        a: 1,
        b: 2,
        c: 4,
        d: [4, 5, 3],
        e: [6, 7]
      };

      var merged = _collection2.merge.apply(void 0, [{}].concat(inputs));

      expect(merged).toEqual(expected);
    });
    test('complete example', function () {
      var base = (0, _collection2.clone)(complexObject);
      var bottomLevelBase = (0, _collection2.clone)(complexObject);
      var topLevelBase = (0, _collection2.clone)(complexObject);
      var propToDelete = 'single';
      var newValue = 'new value';
      bottomLevelBase.primitiveOverlay = 0;
      bottomLevelBase.iterableOverlay = {};
      var bottomLevel = bottomLevelBase;
      delete topLevelBase[propToDelete];
      topLevelBase.newProperty = newValue;
      topLevelBase.parent.child.grandChild = newValue;
      topLevelBase.complexArray[0].innerArray = [0];
      topLevelBase.primitiveOverlay = simpleObj;
      topLevelBase.iterableOverlay = simpleObj;
      var topLevel = topLevelBase;
      var merged = (0, _collection2.merge)(base, bottomLevel, topLevel);
      expect(base).not.toEqual(complexObject);
      expect(merged).toHaveProperty(propToDelete);
      expect(merged.newProperty).toEqual(newValue);
      expect(merged.parent.child.grandChild).toEqual(newValue);
      expect(merged.primitiveOverlay).toEqual(simpleObj);
      expect(topLevelBase.iterableOverlay).toEqual(simpleObj);
      expect(merged.complexArray !== topLevel.complexArray).toEqual(true);
      expect(merged.complexArray[0].innerArray[0]).toEqual(0);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var mCollections = (0, _collection.values)((0, _helpers.rndNested)());

        var merged = _collection2.merge.apply(void 0, [{}].concat((0, _toConsumableArray2["default"])(mCollections)));

        testMerge.apply(void 0, [merged].concat((0, _toConsumableArray2["default"])(mCollections)));
      });
    });
  });
  describe('overlay overlays multiple objects into one', function () {
    test('example', function () {
      var inputs = [{
        a: 1,
        c: 3,
        d: [1, 2, 3],
        e: [5]
      }, {
        b: 2,
        c: 4,
        d: [4, 5],
        e: [6, 7]
      }];
      var expected = {
        a: 1,
        b: 2,
        c: 4,
        d: [4, 5],
        e: [6, 7]
      };

      var overlaid = _collection2.overlay.apply(void 0, [{}].concat(inputs));

      expect(overlaid).toEqual(expected);
    });
    test('complete example', function () {
      var base = (0, _collection2.clone)(complexObject);
      var bottomLevelBase = (0, _collection2.clone)(complexObject);
      var topLevelBase = (0, _collection2.clone)(complexObject);
      var propToDelete = 'single';
      var newValue = 'new value';
      bottomLevelBase.primitiveOverlay = 0;
      bottomLevelBase.iterableOverlay = {};
      var bottomLevel = bottomLevelBase;
      delete topLevelBase[propToDelete];
      topLevelBase.newProperty = newValue;
      topLevelBase.parent.child.grandChild = newValue;
      topLevelBase.complexArray.innerArray = [0];
      topLevelBase.primitiveOverlay = simpleObj;
      topLevelBase.iterableOverlay = simpleObj;
      var topLevel = topLevelBase;
      var overlaid = (0, _collection2.overlay)(base, bottomLevel, topLevel);
      expect(base).not.toEqual(complexObject);
      expect(overlaid).toHaveProperty(propToDelete);
      expect(overlaid.newProperty).toEqual(newValue);
      expect(overlaid.parent.child.grandChild).toEqual(newValue);
      expect(overlaid.primitiveOverlay).toEqual(simpleObj);
      expect(topLevelBase.iterableOverlay).toEqual(simpleObj);
      expect(overlaid.complexArray === topLevel.complexArray).toEqual(true);
      expect(overlaid.complexArray.innerArray === topLevel.complexArray.innerArray).toEqual(true);
    });
    test('randomized test', function () {
      var testOverlay = function testOverlay(overlaid) {
        for (var _len4 = arguments.length, collections = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          collections[_key4 - 1] = arguments[_key4];
        }

        (0, _collection.map)(overlaid, function (value, key) {
          // TODO: Use library filter.
          var getChildren = function getChildren() {
            return (0, _collection.map)(collections.filter(function (collection) {
              return (0, _reflection.isIterable)(collection) && Object.hasOwnProperty(collection, key);
            }), function (child) {
              return child[key];
            });
          };

          (0, _reflection.isDict)(value) ? testOverlay.apply(void 0, [value].concat((0, _toConsumableArray2["default"])(getChildren()))) : (0, _helpers.expectEquals)(value, getChildren()[0]);
        });
      };

      (0, _helpers.retry)(function () {
        var inputs = (0, _collection.values)((0, _helpers.rndNested)());

        var overlaid = _collection2.overlay.apply(void 0, [{}].concat((0, _toConsumableArray2["default"])(inputs)));

        testOverlay.apply(void 0, [overlaid].concat((0, _toConsumableArray2["default"])(reverseArray(inputs))));
      });
    });
  });
  describe('combine combines multiple objects into one', function () {
    test('example', function () {
      var inputs = [{
        a: 1,
        c: 3,
        d: [1, 2, 3],
        e: [5]
      }, {
        b: 2,
        c: 4,
        d: [4, 5],
        e: [6, 7]
      }];
      var expected = {
        a: 1,
        b: 2,
        c: 4,
        d: [1, 2, 3, 4, 5],
        e: [5, 6, 7]
      };

      var combined = _collection2.combine.apply(void 0, [{}].concat(inputs));

      expect(combined).toEqual(expected);
    });
    test('complete example', function () {
      var base = (0, _collection2.clone)(complexObject);
      var underlayBase = (0, _collection2.clone)(complexObject);
      var overlayBase = (0, _collection2.clone)(complexObject);
      var propToDelete = 'single';
      var newValue = 'new value';
      underlayBase.primitiveOverlay = 0;
      underlayBase.iterableOverlay = {};
      var layerOne = underlayBase;
      delete overlayBase[propToDelete];
      overlayBase.newProperty = newValue;
      overlayBase.parent.child.grandChild = newValue;
      overlayBase.complexArray[0].innerArray = [0];
      overlayBase.primitiveOverlay = simpleObj;
      overlayBase.iterableOverlay = simpleObj;
      var layerTwo = overlayBase;
      var combined = (0, _collection2.combine)(base, layerOne, layerTwo);
      expect(base).not.toEqual(complexObject);
      expect(combined).toHaveProperty(propToDelete);
      expect(combined.newProperty).toEqual(newValue);
      expect(combined.parent.child.grandChild).toEqual(newValue);
      expect(combined.array).toEqual(complexObject.array.concat(underlayBase.array).concat(overlayBase.array));
      expect(combined.primitiveOverlay).toEqual(simpleObj);
      expect(overlayBase.iterableOverlay).toEqual(simpleObj);
      expect(combined.complexArray).toEqual([complexObject.complexArray[0], underlayBase.complexArray[0], overlayBase.complexArray[0]]);
    });
    test('randomized test', function () {
      var getMatchingIndex = function getMatchingIndex(arr, index) {
        return index <= 0 ? arr.length : index;
      };

      var combineChildren = function combineChildren(reversedChildren) {
        var sliceIndex = reversedChildren.findIndex(function (element) {
          return !(0, _reflection.isArray)(element);
        });
        return reverseArray(reversedChildren.slice(0, getMatchingIndex(reversedChildren, sliceIndex))).flat();
      };

      var getChildren = function getChildren(collections, key) {
        return (// TODO: Use library filter.
          (0, _collection.map)(collections.filter(function (collection) {
            return (0, _reflection.isIterable)(collection) && Object.hasOwnProperty(collection, key);
          }), function (child) {
            return child[key];
          })
        );
      };

      var testCombine = function testCombine(combined) {
        for (var _len5 = arguments.length, collections = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
          collections[_key5 - 1] = arguments[_key5];
        }

        return (0, _collection.map)(combined, function (value, key) {
          return (0, _reflection.isDict)(value) ? testCombine.apply(void 0, [value].concat((0, _toConsumableArray2["default"])((0, _helpers.till)(getChildren(collections, key), _reflection.isDict)))) : (0, _reflection.isArray)(value) ? (0, _helpers.expectEquals)(value, combineChildren(getChildren(collections, key))) : (0, _helpers.expectEquals)(value, getChildren(collections, key)[0]);
        });
      };

      (0, _helpers.retry)(function () {
        var inputs = (0, _collection.values)((0, _helpers.rndNested)()); // TODO: Fix. Coverage requirement is not met sometimes.

        var combined = _collection2.combine.apply(void 0, [{}].concat((0, _toConsumableArray2["default"])(inputs)));

        testCombine.apply(void 0, [combined].concat((0, _toConsumableArray2["default"])(reverseArray(inputs))));
      });
    });
  });
  describe('fill fills the missing properties of the given base' + ' from those of the extensions', function () {
    test('example', function () {
      var inputs = [{
        a: 1,
        c: 3,
        d: [1, 2, 3],
        e: {
          f: 4
        }
      }, {
        b: 2,
        d: [4, 5],
        e: {
          f: 6,
          g: 7
        },
        g: 8
      }];
      var expected = {
        a: 1,
        b: 2,
        c: 3,
        d: [1, 2, 3],
        e: {
          f: 4,
          g: 7
        },
        g: 8
      };

      var filled = _collection2.fill.apply(void 0, inputs);

      expect(filled).toEqual(expected);
    });
    test('complete example', function () {
      var baseProp = Symbol('baseProp');
      var underlayProp = Symbol('underlayProp');
      var overlayProp = Symbol('overlayProp');
      var base = mockObj(['a'], baseProp);
      var layerOne = (0, _collection2.secure)(mockObj(['a', 'b'], underlayProp));
      var layerTwo = (0, _collection2.secure)(mockObj(['b', 'c'], overlayProp));
      var filled = (0, _collection2.fill)(base, layerOne, layerTwo);
      expect(filled).toEqual(base);
      expect(base).toEqual({
        a: baseProp,
        b: underlayProp,
        c: overlayProp
      });
    });
    test('randomized test', function () {
      var testFill = function testFill(filled) {
        for (var _len6 = arguments.length, collections = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
          collections[_key6 - 1] = arguments[_key6];
        }

        testMerge.apply(void 0, [filled].concat((0, _toConsumableArray2["default"])(reverseArray(collections))));
      };

      (0, _helpers.retry)(function () {
        var collections = (0, _collection.values)((0, _helpers.rndNested)());

        var filled = _collection2.fill.apply(void 0, [{}].concat((0, _toConsumableArray2["default"])(collections)));

        testFill.apply(void 0, [filled].concat((0, _toConsumableArray2["default"])(collections)));
      });
    });
  });
  describe('merge, combine and overlay shares some behaviors', function () {
    test('they work with multiple extensions', function () {
      expect((0, _collection2.merge)({
        a: 1
      }, {
        b: 2
      }, {
        c: 3
      })).toEqual({
        a: 1,
        b: 2,
        c: 3
      });
      expect((0, _collection2.combine)({
        a: [1]
      }, {
        a: [2],
        c: 3
      })).toEqual({
        a: [1, 2],
        c: 3
      });
      expect((0, _collection2.overlay)({
        a: [1, 2, 3]
      }, {
        a: [4, 5],
        b: 6
      })).toEqual({
        a: [4, 5],
        b: 6
      });
      expect((0, _collection2.fill)({
        a: 1,
        b: [2, 3]
      }, {
        b: 4,
        c: 5
      })).toEqual({
        a: 1,
        b: [2, 3],
        c: 5
      });
    });
    test('they ignore undefined values as extensions', function () {
      expect((0, _collection2.merge)({
        a: 1
      }, undefined, {
        c: 3
      })).toEqual({
        a: 1,
        c: 3
      });
      expect((0, _collection2.combine)({
        a: [1]
      }, undefined, {
        a: [2]
      })).toEqual({
        a: [1, 2]
      });
      expect((0, _collection2.overlay)({
        a: [1]
      }, undefined, {
        a: [4],
        b: 6
      })).toEqual({
        a: [4],
        b: 6
      });
      expect((0, _collection2.fill)({
        a: [1]
      }, undefined, {
        a: 2,
        b: 3
      })).toEqual({
        a: [1],
        b: 3
      });
    });
    test('they work with simple arrays', function () {
      expect((0, _collection2.merge)([0, 1], [1])).toEqual([1, 1]);
      expect((0, _collection2.combine)([0, 1], [1])).toEqual([0, 1, 1]);
      expect((0, _collection2.overlay)([0, 1, 2], [3, 4])).toEqual([3, 4, 2]);
      expect((0, _collection2.fill)([0, 1, 2, 3], [4, 5])).toEqual([0, 1, 2, 3]);
    });
  });
  describe('flip swaps the keys and values of the given object', function () {
    test('example', function () {
      expect((0, _collection2.flip)(simpleObj)).toEqual({
        1: 'a',
        2: 'b'
      });
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var collection = (0, _helpers.rndDict)();
        var expectation = (0, _collection.fromEntries)((0, _collection.map)((0, _collection.entries)(collection), function (_ref7) {
          var _ref8 = (0, _slicedToArray2["default"])(_ref7, 2),
              key = _ref8[0],
              value = _ref8[1];

          return [value, key];
        }));
        expect((0, _collection2.flip)(collection)).toEqual(expectation);
      });
    });
  });
  describe('flipMany builds an one-to-one inverted mapping of' + ' a many to one object', function () {
    test('example', function () {
      // TODO: Decide whether the values could be objects.
      var oneToMany = {
        a: [1, 2]
      };
      var invertedOneToOne = {
        1: 'a',
        2: 'a'
      };
      expect((0, _collection2.flipMany)(oneToMany)).toEqual(invertedOneToOne);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var data = (0, _collection.secure)((0, _collection.map)((0, _helpers.rndDict)(), function () {
          return (0, _collection.map)((0, _helpers.rndRange)(), function () {
            return Symbol((0, _random.rndString)());
          });
        }));
        var expected = {};
        (0, _collection.keys)(data).forEach(function (key) {
          return data[key].forEach(function (item) {
            return expected[item] = key;
          });
        });
        expect((0, _collection2.flipMany)(data)).toEqual(expected);
      });
    });
  });
  describe('translate gives the translation of the source based' + ' on a translation map', function () {
    test('example', function () {
      var sourceObject = {
        a: 1,
        b: {
          c: 2
        },
        d: 3
      };
      var selectorObject = {
        x: 'a',
        y: '/b/c',
        z: {
          w: 'd'
        }
      };
      var expectedObject = {
        x: 1,
        y: 2,
        z: {
          w: 3
        }
      };
      var sourceArray = ['a', 'b', ['c'], 'd'];
      var selectorArray = ['1', '2/0', ['3']];
      var expectedArray = ['b', 'c', ['d']];
      expect((0, _collection2.translate)(sourceObject, selectorObject)).toEqual(expectedObject);
      expect((0, _collection2.translate)(sourceArray, selectorArray)).toEqual(expectedArray);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var source = (0, _helpers.rndCollection)();
        var keysArr = (0, _random.rndValues)((0, _collection.keys)(source));
        var selector = (0, _collection.secure)((0, _collection.reduce)(keysArr, function (acc, key) {
          return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2["default"])({}, (0, _random.rndString)(), key));
        }, {}));
        var expected = (0, _collection.map)(selector, function (value) {
          return source[value];
        });
        expect((0, _collection2.translate)(source, selector)).toEqual(expected);
      });
    });
  });
  describe('fromEntries builds an object out of entries', function () {
    test('example', function () {
      expect((0, _collection2.fromEntries)((0, _collection2.entries)(simpleObj))).toEqual(simpleObj);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var iterable = (0, _helpers.rndCollection)();
        var expectation = (0, _reflection.isArray)(iterable) ? (0, _collection.dict)((0, _collection2.values)(iterable)) : iterable;
        expect((0, _collection2.fromEntries)((0, _collection.entries)(iterable))).toEqual(expectation);
      });
    });
  });
  describe('entries builds an array of key value pairs' + ' from given collection', function () {
    test('example', function () {
      expect((0, _collection2.entries)(simpleArray)).toEqual([[0, 1], [1, 2]]);
      expect((0, _collection2.entries)(simpleObj)).toEqual([['a', 1], ['b', 2]]);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var iterable = (0, _helpers.rndCollection)();
        var expectation = (0, _collection.values)((0, _collection.map)(iterable, function (value, key) {
          return (// TODO: Remove converters post publishing.
            [_helpers.converters[(0, _reflection.inferType)(iterable)](key), value]
          );
        }));
        expect((0, _collection2.entries)(iterable)).toEqual(expectation);
      });
    });
  });
  describe('select helps building sub-objects with selectors', function () {
    describe('examples', function () {
      test('select returns a sub-object of the given object,' + ' with the given array of properties', function () {
        expect((0, _collection2.select)(simpleObj, ['a'])).toEqual({
          a: 1
        });
      });
      test('select returns a sub-object of the given object,' + ' with the properties in the given selector object', function () {
        expect((0, _collection2.select)(simpleObj, {
          'some-thing': 'a',
          'some value': 'keyNotInSource'
        })).toEqual({
          a: 1
        });
      });
      test('select returns a sub-array of the given array,' + ' with the given array of properties', function () {
        expect((0, _collection2.select)(simpleArray, [0])).toEqual([1]);
      });
    });
    describe('randomized tests', function () {
      test('select returns a sub-collection of the given collection,' + 'with the given selector collection', function () {
        (0, _helpers.retry)(function () {
          var collection = (0, _helpers.rndCollection)(); // eslint-disable-next-line max-len

          var selector = (0, _collection.secure)(arrayOrObject((0, _helpers.rndKeys)(collection)));
          var expectation = (0, _collection.clean)((0, _collection.filter)(collection, function (dummy, key) {
            return (0, _collection.values)(selector) // TODO: Remove converters.
            .includes(_helpers.converters[(0, _reflection.inferType)(collection)](key));
          }));
          var selected = (0, _collection2.select)(collection, selector);
          expect(selected).toEqual(expectation);
        });
      });
    });
  });
  describe('omit helps building sub-objects through omitters', function () {
    describe('examples', function () {
      test('omit returns a sub-object of the given object,' + ' without the given array of properties', function () {
        expect((0, _collection2.omit)(simpleObj, ['a'])).toEqual({
          b: 2
        });
      });
      test('omit returns a sub-object of the given object,' + ' without the properties in the given selector object', function () {
        expect((0, _collection2.omit)(simpleObj, {
          'some-thing': 'a'
        })).toEqual({
          b: 2
        });
      });
      test('omit returns a sub-array of the given array,' + ' without the given array of properties', function () {
        expect((0, _collection2.clean)((0, _collection2.omit)(simpleArray, [0]))).toEqual([2]);
      });
    });
    describe('randomized tests', function () {
      test('omit returns a sub-collection of the given collection,' + ' without the given collection of properties', function () {
        (0, _helpers.retry)(function () {
          var collection = (0, _helpers.rndCollection)(); // eslint-disable-next-line max-len

          var selector = (0, _collection.secure)(arrayOrObject((0, _helpers.rndKeys)(collection)));
          var expectation = (0, _collection.clean)((0, _collection.filter)(collection, function (dummy, key) {
            return !(0, _collection.values)(selector) // TODO: Remove converters.
            .includes(_helpers.converters[(0, _reflection.inferType)(collection)](key));
          }));
          var omitted = (0, _collection2.omit)(collection, selector);
          expect(omitted).toEqual(expectation);
        });
      });
    });
  });
  describe('result returns the value for the given simple path' + ' or escaped path', function () {
    test('example', function () {
      var single = complexObject.single,
          parent = complexObject.parent;
      expect((0, _collection2.result)(complexObject, 'single')).toEqual(single);
      expect((0, _collection2.result)(complexObject, '/single')).toEqual(single);
      expect((0, _collection2.result)(complexObject, 'parent/child')).toEqual(parent.child);
      expect((0, _collection2.result)(complexObject, 'parent/\\/unescaped\\/child')).toEqual(parent['/unescaped/child']);
      expect((0, _collection2.result)(complexObject, 'parent/escaped\\\\\\/child')).toEqual(parent['escaped\\/child']);
      expect((0, _collection2.result)(complexObject, 'array/1')).toEqual(2);
      expect((0, _collection2.result)(complexObject, '')).toEqual(complexObject);
      expect((0, _collection2.result)(complexObject, 'non-existent')).toEqual(undefined);
      expect((0, _collection2.result)(complexObject, 'non-existent/child')).toEqual(undefined);
      expect((0, _collection2.result)({
        '': 1
      }, '//')).toEqual(1);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var data = (0, _helpers.rndNested)((0, _random.rndBetween)(0, 3)); // TODO: use flatMap post publishing

        var flattened = (0, _collection2.walk)(data, function (digest, value) {
          var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
          var childData = digest && (0, _collection2.reduce)(digest, function (acc, childDigest) {
            return (0, _collection2.reduce)(childDigest, function (accOne, val, childPath) {
              accOne["".concat(key, "/").concat(childPath)] = val;
              return accOne;
            }, acc);
          }, {});
          return _objectSpread((0, _defineProperty2["default"])({}, "".concat(key, "/"), value), (0, _reflection.isDefined)(digest) ? childData : {});
        });
        (0, _collection2.map)(flattened, function (value, path) {
          expect((0, _collection2.result)(data, path)).toEqual(value);
        });
      });
    });
  });
  describe('compose returns an object from a list of objects,' + ' with only keys from the first object and the values from' + ' the objects , with a ascending priority', function () {
    test('example', function () {
      expect((0, _collection2.compose)({
        a: 1,
        b: 2,
        c: 3
      }, {
        a: 2,
        b: 3
      }, {
        b: 2,
        d: 1
      })).toEqual({
        a: 2,
        b: 2,
        c: 3
      });
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var input = (0, _collection.values)((0, _helpers.similarCols)());
        var expectation = (0, _collection.select)(_collection.merge.apply(void 0, [{}].concat((0, _toConsumableArray2["default"])(input))), (0, _collection2.keys)(input[0]));
        expect(_collection2.compose.apply(void 0, (0, _toConsumableArray2["default"])(input))).toEqual(expectation);
      });
    });
  });
  describe('patch creates a new variation of a baseObject based on' + ' the given extension, while preserving them both', function () {
    test('example', function () {
      var extensionObj = {
        b: 3
      };
      expect((0, _collection2.patch)(simpleObj, extensionObj)).toEqual({
        a: 1,
        b: 3
      });
      expect(simpleObj).toEqual({
        a: 1,
        b: 2
      });
      expect(extensionObj).toEqual({
        b: 3
      });
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var valueOne = (0, _helpers.rndNested)(3, 3, ['nested', 'array', 'object']);
        var valueTwo = (0, _helpers.rndNested)(3, 3, ['nested', 'array', 'object']);
        var patched = (0, _collection2.patch)(valueOne, valueTwo);
        testMerge(patched, valueOne, valueTwo);
      });
    });
  });
  describe('diff returns the difference between a baseObject' + ' and a comparedObject', function () {
    test('example', function () {
      var difference = (0, _collection2.diff)(baseObject, comparedObject);
      expect(difference).toEqual({
        b: 3,
        c: {
          d: 3
        },
        d: undefined,
        e: [undefined, 1],
        f: 'only in compared'
      }); // NOTE: Verify the presence of missing keys.

      expect(difference).toHaveProperty('d');
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var type = (0, _random.rndValue)(['array', 'object']); // eslint-disable-next-line no-shadow

        var base = (0, _collection.secure)((0, _helpers.rndNested)(3, 3, [type]));
        var compare = (0, _helpers.rndNested)(3, 3, [type]);
        var difference = (0, _collection2.diff)(base, compare);

        var testDifference = function testDifference(childDiff, childBase, childCompare) {
          var compareKeys = (0, _collection.keys)(childCompare);
          return (0, _collection.map)(childDiff, function (value, key) {
            return (0, _reflection.isIterable)(value) ? testDifference(value, childBase[key], childCompare[key]) : compareKeys.includes(key) ? expect(value).toEqual(childCompare[key]) : expect(value).toEqual(undefined);
          });
        };

        testDifference(difference, base, compare);
      });
    });
  });
  describe('diff and patch are complementary', function () {
    test('example', function () {
      var difference = (0, _collection2.diff)(baseObject, comparedObject);
      var patched = (0, _collection2.patch)(baseObject, difference); // NOTE: Verify the absence of missing keys.

      expect(patched).not.toHaveProperty('d');
      expect(patched).toEqual(comparedObject);
    }); // TODO: Randomize while randomizing result test.

    test('randomized test', function () {
      var prop = (0, _random.rndString)();
      var difference = (0, _collection2.diff)(_objectSpread(_objectSpread({}, _helpers.object), {}, (0, _defineProperty2["default"])({}, prop, (0, _random.rndString)())), _helpers.extended);
      var patched = (0, _collection2.patch)(_objectSpread(_objectSpread({}, _helpers.object), {}, (0, _defineProperty2["default"])({}, prop, (0, _random.rndString)())), difference);
      expect(patched).toEqual(_helpers.extended);
    });
  });
  describe('secure prevents further modifications to' + ' the given iterable', function () {
    var newValue = Symbol('value');
    test('example', function () {
      var frozenObject = (0, _collection2.secure)((0, _collection2.clone)(complexObject));
      var frozenArray = frozenObject.array;
      var actions = {
        objectMutation: function objectMutation() {
          frozenObject.parent.child = newValue;
        },
        objectExtension: function objectExtension() {
          frozenObject.parent.newChild = newValue;
        },
        objectDeletion: function objectDeletion() {
          return delete frozenObject.parent.child;
        },
        arrayMutation: function arrayMutation() {
          frozenArray[0] = newValue;
        },
        arrayExtension: function arrayExtension() {
          frozenArray.push(newValue);
        },
        arrayDeletion: function arrayDeletion() {
          return frozenArray.pop();
        }
      };
      (0, _collection2.map)(actions, function (action) {
        return expect(action).toThrow();
      });
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var obj = (0, _helpers.rndNested)();

        var testSecured = function testSecured(data) {
          var key = (0, _random.rndValue)((0, _collection.keys)(data));
          var value = data[key];
          (0, _collection2.map)([function () {
            data[key] = newValue;
          }, function () {
            data[Symbol('newKey')] = newValue;
          }, function () {
            delete data[key];
          }], function (fn) {
            return expect(fn).toThrow(TypeError);
          });
          (0, _reflection.isIterable)(value) && testSecured(value);
        };

        var secured = (0, _collection2.secure)(obj);
        testSecured(secured);
      });
    });
  });
  describe('contains tests whether the base object contains' + ' the compared object', function () {
    test('example', function () {
      expect((0, _collection2.contains)(1, 1)).toBe(true);
      expect((0, _collection2.contains)(1, 0)).toBe(false);
      expect((0, _collection2.contains)(complexObject, (0, _collection2.clone)(complexObject))).toBe(true);
      expect((0, _collection2.contains)(simpleObj, {})).toBe(true);
      expect((0, _collection2.contains)({}, simpleObj)).toBe(false);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var valueOne = (0, _helpers.rndDict)();
        var valueTwo = getUnlike(valueOne);
        expect((0, _collection2.contains)(valueOne, valueTwo)).toEqual(true);
        expect((0, _collection2.contains)(valueTwo, valueOne)).toEqual(false);
      });
    });
  });
  describe('equals tests the value equality of primitives and' + ' complex objects', function () {
    test('example', function () {
      expect((0, _collection2.equals)(1, 1)).toBe(true);
      expect((0, _collection2.equals)(1, 0)).toBe(false);
      expect((0, _collection2.equals)(complexObject, (0, _collection2.clone)(complexObject))).toBe(true);
      expect((0, _collection2.equals)(simpleObj, {})).toBe(false);
      expect((0, _collection2.equals)({}, simpleObj)).toBe(false);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var valueOne = (0, _helpers.rnd)();
        var valueTwo = getUnlike(valueOne);
        expect((0, _collection2.equals)(valueOne, (0, _collection.clone)(valueOne))).toEqual(true);
        expect((0, _collection2.equals)(valueOne, valueTwo)).toEqual(false);
      });
    });
  });
  describe('hasSame tests the given collections for having' + ' the same children', function () {
    test('example', function () {
      expect((0, _collection2.hasSame)(complexArray, (0, _toConsumableArray2["default"])(complexArray))).toBe(true);
      expect((0, _collection2.hasSame)(complexObject, _objectSpread({}, complexObject))).toBe(true);
      expect((0, _collection2.hasSame)(complexArray, (0, _collection2.clone)(complexArray))).toBe(false);
      expect((0, _collection2.hasSame)(complexObject, (0, _collection2.clone)(complexObject))).toBe(false);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var collection = (0, _helpers.rndCollection)();
        var nested = (0, _helpers.rndNested)(3, 3, ['nested']);
        expect((0, _collection2.hasSame)(collection, (0, _collection.clone)(collection))).toEqual(true);
        expect((0, _collection2.hasSame)(nested, (0, _collection2.clone)(nested))).toEqual(false);
      });
    });
  });
  describe('gather gathers the given props from the children' + ' of the given iterable, as an iterable', function () {
    test('example', function () {
      var arrayOfObjects = [{
        a: 1,
        b: 2
      }, {
        a: 2,
        b: 1
      }, // NOTE: Objects do not hold references to undefined values.
      {
        c: 3
      }];
      var objectOfArrays = {
        a: [1, 2],
        b: [2, 1],
        c: [undefined, undefined, 3] // NOTE: Arrays do hold references to undefined values, to preserve indices.

      };
      expect((0, _collection2.gather)(arrayOfObjects, ['a', 'b', 'c'])).toEqual(objectOfArrays);
      expect((0, _collection2.gather)(objectOfArrays, {
        a: 0,
        b: 1,
        c: 2
      })).toEqual(arrayOfObjects);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var collections = (0, _helpers.similarCols)();
        var rndChild = (0, _random.rndValue)(collections);
        var selector = (0, _helpers.rndKeys)(rndChild);
        var expectation = (0, _collection.reduce)(selector, function (acc, selectorKey) {
          acc[selectorKey] = (0, _collection.reduce)(collections, function (expectedChild, child, childKey) {
            (0, _reflection.isDefined)(child[selectorKey]) && (expectedChild[childKey] = child[selectorKey]);
            return expectedChild;
          }, (0, _collection.shell)(collections));
          return acc;
        }, (0, _collection.shell)(rndChild));
        expect((0, _collection2.gather)(collections, selector)).toEqual(expectation);
      });
    });
  });
  describe('pick picks the given prop from the children,' + ' of the given iterable as an iterable', function () {
    test('example', function () {
      var arrayOfObjects = (0, _collection2.secure)([{
        a: 1
      }, {
        a: 2,
        b: 3
      }, {
        c: 4
      }]);
      expect((0, _collection2.pick)(arrayOfObjects, 'a')).toEqual([1, 2]);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var collections = (0, _helpers.similarCols)();
        var prop = (0, _helpers.rndKey)((0, _random.rndValue)(collections));
        var expectation = (0, _collection.map)((0, _collection.filter)(collections, function (child) {
          return Object.hasOwnProperty(child, prop);
        }), function (child) {
          return child[prop];
        });
        expect((0, _collection2.pick)(collections, prop)).toEqual(expectation);
      });
    });
  });
  test('toArray is an alias for values', function () {
    expect(_collection2.toArray).toEqual(_collection2.values);
  });
  describe('toDict converts the given collection into a dictionary', function () {
    test('example', function () {
      expect((0, _collection2.toDict)(simpleArray)).toEqual({
        0: 1,
        1: 2
      });
      expect((0, _collection2.toDict)(simpleObj)).toEqual(simpleObj);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var randomArray = (0, _helpers.rndRange)();
        var expectedArray = (0, _collection.reduce)( // eslint-disable-next-line no-return-assign
        randomArray, function (acc, value, key // eslint-disable-next-line no-sequences
        ) {
          return acc[value] = Number(key), acc;
        }, {});
        var randomObject = (0, _helpers.rndDict)();
        expect((0, _collection2.toDict)(randomArray)).toEqual(expectedArray);
        expect((0, _collection2.toDict)(randomObject)).toEqual(randomObject);
      });
    });
  });
  describe('adopt copies values from extensions into the base', function () {
    test('example', function () {
      var base = {};
      (0, _collection2.adopt)(base, complexObject);
      (0, _collection2.each)(base, function (value, key) {
        expect(value === complexObject[key]).toEqual(true);
      });
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var collection = (0, _helpers.rndCollection)();
        var base = (0, _collection.shell)(collection);
        var adoptedObject = (0, _collection2.adopt)(base, collection);
        expect(base).toEqual(collection);
        expect(adoptedObject).toEqual(base);
      });
    });
  }); // TODO: Revisit for randomization.

  describe('range helps building number-series arrays', function () {
    var abs = Math.abs,
        ceil = Math.ceil;

    var getLength = function getLength(start, end, step) {
      return ceil(abs(end - start) / abs(step));
    };

    var testRange = function testRange(resultedRange, start, end, step) {
      var childCount = getLength(start, end, step);
      expect(resultedRange.length).toBe(childCount);
      expect(resultedRange[0]).toBe(start);
      expect(resultedRange[childCount - 1]).toBe(start + (childCount - 1) * step);
    };

    var buildRange = function buildRange(starts, ends, steps) {
      var start = _random.rndBetween.apply(void 0, (0, _toConsumableArray2["default"])(starts));

      var end = _random.rndBetween.apply(void 0, (0, _toConsumableArray2["default"])(ends)) + start;

      var step = _random.rndBetween.apply(void 0, (0, _toConsumableArray2["default"])(steps));

      var resultingRange = (0, _collection2.range)(start, end, step);
      return [resultingRange, start, end, step];
    };

    test('range returns an array of numbers with the given start, end' + ' and step values', function () {
      testRange.apply(void 0, (0, _toConsumableArray2["default"])(buildRange([5, 9], [5, 9], [1, 3])));
    });
    test('range can return descending series', function () {
      testRange.apply(void 0, (0, _toConsumableArray2["default"])(buildRange([1, 10], [-10, -1], [-3, -1])));
    });
    test('range has default values for all parameters', function () {
      var start = 0;
      var end = 9;
      var step = 1;
      var resultingRange = (0, _collection2.range)();
      testRange(resultingRange, start, end, step);
    });
    describe('range returns an empty array when', function () {
      test('step is 0', function () {
        expect((0, _collection2.range)((0, _random.rndBetween)(-10, 10), (0, _random.rndBetween)(-10, 10), 0)).toEqual([]);
      });
      test('start to end direction and step direction ' + 'are different', function () {
        var start = (0, _random.rndBetween)(-10, 10);
        var step = (0, _random.rndBetween)(-5, 5);
        var end = start - step * (0, _random.rndBetween)(1, 10);
        expect((0, _collection2.range)(start, end, step)).toEqual([]);
      });
      test('start and end are the same', function () {
        var num = (0, _random.rndBetween)(-10, 10);
        expect((0, _collection2.range)(num, num, (0, _random.rndBetween)(-10, 10))).toEqual([]);
      });
    });
  });
  describe('shares', function () {
    describe('examples', function () {
      test('shares tests whether the given objects share the same value' + ' on given properties', function () {
        expect((0, _collection2.shares)(simpleObj, nestedObj, ['a'])).toBe(true);
        expect((0, _collection2.shares)(simpleObj, complexObject, ['a'])).toBe(false);
      });
      test('shares uses \'id\' as the default property compare', function () {
        expect((0, _collection2.shares)({
          id: 1
        }, {
          id: 1
        })).toBe(true);
      });
    });
    describe('randomized test', function () {
      test('shares tests whether the given objects share the same value' + ' on given properties', function () {
        (0, _helpers.retry)(function () {
          var collection = (0, _helpers.rndCollection)();
          var properties = (0, _helpers.rndKeys)(collection);
          expect((0, _collection2.shares)(collection, (0, _collection.clone)(collection), properties)).toBe(true);
          expect((0, _collection2.shares)(collection, arrayOrObject(_helpers.isolated), properties)).toBe(false);
        });
      });
    });
  });
  describe('shuffle shuffles the given collection', function () {
    test('example', function () {
      expect((0, _collection2.shuffle)([1, 2, 3, 4, 5, 6])).not.toEqual([1, 2, 3, 4, 5, 6]);
      expect((0, _collection2.shuffle)({
        a: 1,
        b: 2,
        c: 3,
        d: 4
      })).toEqual({
        a: 1,
        c: 3,
        b: 2,
        d: 4
      });
    });
    test('randomized test', function () {
      var retryCount = 10000;
      var typeTests = {
        array: function array(collection, shuffled) {
          (0, _collection2.map)(shuffled, function (value) {
            return expect(collection.includes(value)).toEqual(true);
          });
          return !(0, _collection.equals)(collection, shuffled);
        },
        object: function object(collection, shuffled) {
          expect((0, _collection.equals)(collection, shuffled)).toEqual(true);
          return !(0, _collection.equals)((0, _collection.keys)(collection), (0, _collection.keys)(shuffled));
        }
      };
      var results = (0, _helpers.retry)(function () {
        var collection = (0, _helpers.rndCollection)();
        var shuffled = (0, _collection2.shuffle)(collection);
        return typeTests[(0, _reflection.inferType)(collection)](collection, shuffled);
      }, retryCount); // TODO: Replace with fn.self & collection.filter post publishing.

      var successCount = results.filter(function (value) {
        return value;
      }).length;
      expect((0, _helpers.isAcceptable)(successCount, retryCount)).toEqual(true);
    });
  });
  describe('sort sorts the given collection', function () {
    describe('examples', function () {
      test('sort sorts the collection based on given sorter ', function () {
        expect((0, _collection2.sort)([10, 2, 8, 4], _sorters.ascending)).toEqual([2, 4, 8, 10]);
        expect((0, _collection2.sort)({
          a: 10,
          b: 2,
          c: 8,
          d: 4
        }, _sorters.descending)).toEqual({
          a: 10,
          c: 8,
          d: 4,
          b: 2
        });
      });
      test('sort uses ascending as the default sorter', function () {
        expect((0, _collection2.sort)([10, 2, 8, 4])).toEqual([2, 4, 8, 10]);
        expect((0, _collection2.sort)({
          a: 10,
          b: 2,
          c: 8,
          d: 4
        })).toEqual({
          b: 2,
          d: 4,
          c: 8,
          a: 10
        });
      });
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var collection = (0, _helpers.rndCollection)();
        var input = (0, _collection.reduce)(collection, function (acc, dummy, key) {
          acc.result[key] = acc.count;
          acc.count += 1;
          return acc;
        }, {
          count: 0,
          result: (0, _collection.shell)(collection)
        }).result;
        var shuffled = (0, _collection.shuffle)(input);
        var sorted = (0, _collection2.sort)(shuffled);
        expect(sorted).toEqual(input);
      });
    });
  });
  describe('keys returns the keys of given collection', function () {
    test('example', function () {
      expect((0, _collection2.keys)(['a', 'b', 'c'])).toEqual([0, 1, 2]);
      expect((0, _collection2.keys)({
        a: 1,
        b: 2,
        c: 3
      })).toEqual(['a', 'b', 'c']);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var collection = (0, _collection.clone)((0, _helpers.rndCollection)());
        var randomKeys = (0, _helpers.rndKeys)(collection);
        (0, _collection.map)(collection, function (dummy, key) {
          return (// TODO: Remove converters after publishing.
            !randomKeys.includes(_helpers.converters[(0, _reflection.inferType)(collection)](key)) && delete collection[key]
          );
        });
        (0, _collection.secure)(collection);
        var keysResult = (0, _collection2.keys)(collection);
        expect(keysResult).toEqual(randomKeys);
      });
    });
  });
  describe('length returns the length of given collection', function () {
    test('example', function () {
      var sparseArray = [];
      sparseArray[4] = 'a';
      expect((0, _collection2.length)(sparseArray)).toEqual(5);
      expect((0, _collection2.length)([1, 2, 3])).toEqual(3);
      expect((0, _collection2.length)({
        a: 1,
        b: 2
      })).toEqual(2);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var collection = (0, _helpers.rndCollection)();
        expect((0, _collection2.length)(collection)).toEqual((0, _collection.values)(collection).length);
      });
    });
  });
  describe('count returns the number of values in give collection', function () {
    test('example', function () {
      var sparseArray = [];
      sparseArray[4] = 'a';
      expect((0, _collection2.count)(sparseArray)).toEqual(1);
      expect((0, _collection2.count)({
        a: 1,
        b: 2
      })).toEqual(2);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var iterable = (0, _helpers.rndCollection)();
        var selector = (0, _helpers.rndKeys)(iterable);
        var collection = (0, _collection.select)(iterable, selector);
        expect((0, _collection2.count)(collection)).toEqual(selector.length);
      });
    });
  });
  describe('flatMap return combination of path with values', function () {
    test('example', function () {
      var data = {
        a: 1,
        b: {
          c: 3
        }
      };
      var expected = {
        '/': data,
        '/a/': 1,
        '/b/': {
          c: 3
        },
        '/b/c/': 3
      };
      expect((0, _collection2.flatMap)(data)).toEqual(expected);
    });
    test('randomized test', function () {
      (0, _helpers.retry)(function () {
        var data = (0, _helpers.rndNested)((0, _random.rndBetween)(0, 5));

        var buildExpectation = function buildExpectation(input) {
          var parentPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
          return _objectSpread(_objectSpread({}, (0, _collection2.reduce)((0, _reflection.isIterable)(input) ? input : {}, function (acc, child, key) {
            return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2["default"])({}, "".concat(parentPath, "/").concat(key, "/"), child), (0, _reflection.isIterable)(child) && buildExpectation(child, "".concat(parentPath, "/").concat(key)));
          }, {})), {}, {
            '/': input
          });
        };

        var expected = buildExpectation(data);
        var flattened = (0, _collection2.flatMap)(data);
        expect(flattened).toEqual(expected);
      });
    });
  });
});